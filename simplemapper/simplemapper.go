// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package simplemapper provides a simple 1-1 mapper for functional translators.
package simplemapper

import (
	"fmt"
	"sort"
	"strings"

	"github.com/golang/glog"
	"google.golang.org/protobuf/proto"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
	"google3/third_party/openconfig/functional_translators/ftutilities"

	gnmipb "github.com/openconfig/gnmi/proto/gnmi"
)

// bindKeys extracts variable bindings from a concrete path by comparing it with a
// path containing variables. For example, given a varPath
// /interfaces/interface[name=<ifname>]/state/oper-status and a concretePath
// /interfaces/interface[name=eth0]/state/oper-status, it returns {"<ifname>": "eth0"}.
// varPath is a gNMI path where some key values are variables (e.g. "<ifname>").
// concretePath is a gNMI path with specific values for keys, usually from a gNMI notification.
func bindKeys(varPath *gnmipb.Path, concretePath *gnmipb.Path) (map[string]string, error) {
	ret := make(map[string]string)
	if len(varPath.GetElem()) != len(concretePath.GetElem()) {
		return nil, fmt.Errorf("path with variables and concrete path have different lengths: %d vs %d", len(varPath.GetElem()), len(concretePath.GetElem()))
	}
	for i, elemBind := range varPath.GetElem() {
		elem := concretePath.GetElem()[i]
		if elemBind.Name != elem.Name {
			return nil, fmt.Errorf("path with variables and concrete path have different elem names: %q vs %q", elemBind.Name, elem.Name)
		}
		if len(elemBind.GetKey()) != len(elem.GetKey()) {
			return nil, fmt.Errorf("path with variables and concrete path have different key lengths: %d vs %d", len(elemBind.GetKey()), len(elem.GetKey()))
		}
		for key, valBind := range elemBind.GetKey() {
			if !isVar(valBind) { // Constant key, e.g. /afi-safis/afi-safi[afi-safi-name=IPV4_UNICAST]/
				continue
			}
			val, ok := elem.GetKey()[key]
			if !ok {
				return nil, fmt.Errorf("key from path with variables not found in concrete path: %q", key)
			}
			if _, ok := ret[valBind]; ok {
				return nil, fmt.Errorf("duplicate var %q", valBind)
			}
			ret[valBind] = val
		}
	}
	return ret, nil
}

// applyBind substitutes variables in a path with their bound values.
// For example, given bindings {"<ifname>": "eth0"} and a varPath
// /interfaces/interface[name=<ifname>]/config/description, it returns a new path
// /interfaces/interface[name=eth0]/config/description.
func applyBind(bindings map[string]string, varPath *gnmipb.Path) (*gnmipb.Path, error) {
	ret := proto.Clone(varPath).(*gnmipb.Path)
	for _, elem := range ret.GetElem() {
		newKeys := make(map[string]string)
		for key, name := range elem.GetKey() {
			if isVar(name) {
				val, ok := bindings[name]
				if !ok {
					return nil, fmt.Errorf("variable %q not found in bindings", name)
				}
				newKeys[key] = val
			} else { // Constant key, e.g. /afi-safis/afi-safi[afi-safi-name=IPV4_UNICAST]/
				newKeys[key] = name
			}
		}
		elem.Key = newKeys
	}
	return ret, nil
}

func isVar(s string) bool {
	return strings.HasPrefix(s, "<") && strings.HasSuffix(s, ">")
}

func varsToWildcards(path *gnmipb.Path) *gnmipb.Path {
	ret := proto.Clone(path).(*gnmipb.Path)
	for _, elem := range ret.GetElem() {
		newKeys := make(map[string]string)
		for key, name := range elem.GetKey() {
			if !isVar(name) {
				newKeys[key] = name
				continue
			}
			newKeys[key] = "*"
		}
		elem.Key = newKeys
	}
	return ret
}

// TODO: Support the rest of the types.
// TODO: Support automatic casting when types are different in input and output schemas.
func yangValToGNMIVal(val any) (*gnmipb.TypedValue, error) {
	switch v := val.(type) {
	case *string:
		return &gnmipb.TypedValue{Value: &gnmipb.TypedValue_StringVal{StringVal: *v}}, nil
	case *bool:
		return &gnmipb.TypedValue{Value: &gnmipb.TypedValue_BoolVal{BoolVal: *v}}, nil
	case *float64:
		return &gnmipb.TypedValue{Value: &gnmipb.TypedValue_DoubleVal{DoubleVal: *v}}, nil
	default:
		return nil, fmt.Errorf("unsupported type: %v", v)
	}
}

// SchemaFn is a function that returns a ygot schema. These are typically auto-generated by ygot, e.g. interfaces.Schema.
type SchemaFn func() (*ytypes.Schema, error)

type pathMapping struct {
	input  *gnmipb.Path
	output *gnmipb.Path
}

// parseMapperPath converts a path string to a gNMI path and a schema path. It takes care of
// populating gnmi origin if the paths tarts with a "valid origin".
func parseMapperPath(pathStr string) (*gnmipb.Path, string, error) {
	pathStr = strings.TrimPrefix(pathStr, "/")
	origin, elems, _ := strings.Cut(pathStr, "/")
	if _, ok := ftutilities.ValidOrigins[origin]; !ok {
		origin = ""
		elems = pathStr
	}
	path, err := ygot.StringToStructuredPath(elems)
	if err != nil {
		return nil, "", fmt.Errorf("failed to convert path to gnmi path: %v", err)
	}
	path.Origin = origin
	schemaPath := ftutilities.GNMIPathToSchemaString(path, false)
	schemaPath = ftutilities.ForcePathPrefix(schemaPath, origin)
	return path, schemaPath, nil
}

// NewSimpleMapper creates a new simple mapper.
func NewSimpleMapper(inSchema, outSchema SchemaFn, outputToInput map[string]string, deleteHandler func(*gnmipb.Notification) ([]*gnmipb.Path, error)) (*SimpleMapper, error) {
	var mappings []pathMapping
	outputToInputSchemaStrings := make(map[string][]string)
	outputToInputSchemaMap := make(map[string]map[string]bool)
	for o, i := range outputToInput {
		oPath, oSchemaPath, err := parseMapperPath(o)
		if err != nil {
			return nil, err
		}
		iPath, iSchemaPath, err := parseMapperPath(i)
		if err != nil {
			return nil, err
		}
		mappings = append(mappings, pathMapping{
			input:  iPath,
			output: oPath,
		})
		if _, ok := outputToInputSchemaMap[oSchemaPath]; !ok {
			outputToInputSchemaMap[oSchemaPath] = make(map[string]bool)
		}
		outputToInputSchemaMap[oSchemaPath][iSchemaPath] = true
	}
	for o, is := range outputToInputSchemaMap {
		for i := range is {
			outputToInputSchemaStrings[o] = append(outputToInputSchemaStrings[o], i)
		}
		sort.Strings(outputToInputSchemaStrings[o])
	}

	isc, err := inSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot load input schema, %w", err)
	}
	osc, err := outSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot load output schema, %w", err)
	}

	return &SimpleMapper{
		inSchema:                   isc,
		outSchema:                  osc,
		mapEntries:                 mappings,
		deleteHandler:              deleteHandler,
		outputToInputSchemaStrings: outputToInputSchemaStrings,
	}, nil
}

// SimpleMapper objects translate notifications with simple 1-1 leaf relabeling.
type SimpleMapper struct {
	inSchema                   *ytypes.Schema
	outSchema                  *ytypes.Schema
	mapEntries                 []pathMapping
	deleteHandler              func(*gnmipb.Notification) ([]*gnmipb.Path, error)
	outputToInputSchemaStrings map[string][]string
}

// OutputToInputSchemaStrings returns the parsed schema path strings for use in the functional translator constructor.
func (m *SimpleMapper) OutputToInputSchemaStrings() map[string][]string {
	return m.outputToInputSchemaStrings
}

func (m *SimpleMapper) updateHandler(inSchema, outSchema *ytypes.Schema, notification *gnmipb.Notification) (*gnmipb.Notification, error) {
	blankRoot, err := ygot.DeepCopy(inSchema.Root)
	if err != nil {
		return nil, fmt.Errorf("failed to deep copy input schema root, %v", err)
	}
	defer func() { inSchema.Root = blankRoot }()

	if err := ytypes.UnmarshalNotifications(inSchema, []*gnmipb.Notification{notification}, nil); err != nil {
		return nil, fmt.Errorf("failed to unmarshal notifications with input schema: %v", err)
	}

	returnRootGoStruct, err := ygot.DeepCopy(outSchema.Root)
	if err != nil {
		return nil, fmt.Errorf("failed to deep copy output schema root: %v", err)
	}
	for _, mapEntry := range m.mapEntries {
		// TODO: Consider storing this in the pathMapping struct as an optimization.
		inWildcardPath := varsToWildcards(mapEntry.input)

		nodes, err := ytypes.GetNode(inSchema.RootSchema(), inSchema.Root, inWildcardPath, &ytypes.GetHandleWildcards{})
		if err != nil {
			// We get an error if the path doesn't exist, which is benign, so we log and continue for all errors.
			// TODO: Consider returning other types of errors if we can distinguish them.
			log.V(1).Infof("entry skipped, no nodes found: %v", err)
			continue
		}

		for _, tn := range nodes {
			bindings, err := bindKeys(mapEntry.input, tn.Path)
			if err != nil {
				return nil, fmt.Errorf("failed to bind keys for input path: %v", err)
			}
			outPath, err := applyBind(bindings, mapEntry.output)
			if err != nil {
				return nil, fmt.Errorf("failed to apply bindings to output path: %v", err)
			}
			if _, _, err := ytypes.GetOrCreateNode(outSchema.RootSchema(), returnRootGoStruct, outPath); err != nil {
				return nil, fmt.Errorf("failed to get or create node for output path: %v", err)
			}
			val, err := yangValToGNMIVal(tn.Data)
			if err != nil {
				return nil, fmt.Errorf("failed to convert yang val to gNMI val: %v", err)
			}
			if err := ytypes.SetNode(outSchema.RootSchema(), returnRootGoStruct, outPath, val); err != nil {
				return nil, fmt.Errorf("failed to set node for output path: %v", err)
			}
		}
	}

	outgoingNotifications, err := ygot.TogNMINotifications(returnRootGoStruct, notification.GetTimestamp(), ygot.GNMINotificationsConfig{UsePathElem: true})
	if err != nil {
		return nil, fmt.Errorf("failed to convert outgoing notification: %v", err)
	}
	if len(outgoingNotifications) != 1 {
		return nil, fmt.Errorf("received %d notifications, expected only one: %v", len(outgoingNotifications), outgoingNotifications)
	}
	if outgoingNotifications[0].GetPrefix() == nil {
		outgoingNotifications[0].Prefix = &gnmipb.Path{}
	}
	outgoingNotifications[0].Prefix.Origin = "openconfig"
	return outgoingNotifications[0], nil
}

// Handler translates gNMI notifications. This should be used as the Translate function for a functional translator.
// TODO(team): Write unit tests for this, besides those in the functional translators that use this.
func (m *SimpleMapper) Handler(sr *gnmipb.SubscribeResponse) (*gnmipb.SubscribeResponse, error) {
	notification := sr.GetUpdate()
	outgoingNotification, err := m.updateHandler(m.inSchema, m.outSchema, notification)
	if err != nil {
		return nil, fmt.Errorf("failed to handle updates: %v", err)
	}
	// TODO: It seems like this can't be nil, so we may not need this nil check.
	if outgoingNotification == nil {
		outgoingNotification = &gnmipb.Notification{}
	}
	if outgoingNotification.GetPrefix() == nil {
		outgoingNotification.Prefix = &gnmipb.Path{}
	}
	outgoingNotification.Prefix.Origin = "openconfig"
	outgoingNotification.Prefix.Target = sr.GetUpdate().GetPrefix().GetTarget()
	outgoingNotification.Timestamp = sr.GetUpdate().GetTimestamp()

	deletes, err := m.deleteHandler(notification)
	if err != nil {
		return nil, fmt.Errorf("failed to handle deletes: %v", err)
	}
	outgoingNotification.Delete = deletes

	outgoingNotification = ftutilities.Filter(outgoingNotification, func(path *gnmipb.Path, isDelete bool) bool {
		notificationSchema := ftutilities.GNMIPathToSchemaString(path, false)
		// If update, exact match
		if !isDelete {
			_, ok := m.outputToInputSchemaStrings[notificationSchema]
			return ok
		}

		// If delete, prefix match
		for ftOutputSchema := range m.outputToInputSchemaStrings {
			if strings.HasPrefix(ftOutputSchema, notificationSchema) {
				return true
			}
		}
		return false
	})
	if outgoingNotification == nil {
		return nil, nil
	}
	return &gnmipb.SubscribeResponse{
		Response: &gnmipb.SubscribeResponse_Update{
			Update: outgoingNotification,
		},
	}, nil
}
