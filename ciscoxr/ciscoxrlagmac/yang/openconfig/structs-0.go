/*
Package openconfig is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /usr/local/google/home/singhavnish/go/pkg/mod/github.com/openconfig/ygot@v0.33.0/genutil/names.go
using the following YANG input files:
  - public/release/models/interfaces/openconfig-interfaces.yang
  - public/release/models/interfaces/openconfig-if-ethernet.yang
  - public/release/models/lacp/openconfig-lacp.yang
  - ciscoxr/ciscoxrlagmac/yang/openconfig/restriction.yang

Imported modules were sourced from:
  - public/release/models/...
  - public/third_party/...
*/
package openconfig

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &Device{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// Device represents the /device YANG schema element.
type Device struct {
	ΛMetadata   []ygot.Annotation                `path:"@" ygotAnnotation:"true"`
	Interfaces  *OpenconfigInterfaces_Interfaces `path:"interfaces" module:"openconfig-interfaces"`
	ΛInterfaces []ygot.Annotation                `path:"@interfaces" ygotAnnotation:"true"`
	Lacp        *OpenconfigLacp_Lacp             `path:"lacp" module:"openconfig-lacp"`
	ΛLacp       []ygot.Annotation                `path:"@lacp" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that Device implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Device) IsYANGGoStruct() {}

// GetOrCreateInterfaces retrieves the value of the Interfaces field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateInterfaces() *OpenconfigInterfaces_Interfaces {
	if t.Interfaces != nil {
		return t.Interfaces
	}
	t.Interfaces = &OpenconfigInterfaces_Interfaces{}
	return t.Interfaces
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *Device) GetOrCreateLacp() *OpenconfigLacp_Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &OpenconfigLacp_Lacp{}
	return t.Lacp
}

// GetInterfaces returns the value of the Interfaces struct pointer
// from Device. If the receiver or the field Interfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetInterfaces() *OpenconfigInterfaces_Interfaces {
	if t != nil && t.Interfaces != nil {
		return t.Interfaces
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from Device. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Device) GetLacp() *OpenconfigLacp_Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Device"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Device) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Device) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Device.
func (*Device) ΛBelongingModule() string {
	return ""
}

// OpenconfigInterfaces_Interfaces represents the /openconfig-interfaces/interfaces YANG schema element.
type OpenconfigInterfaces_Interfaces struct {
	ΛMetadata  []ygot.Annotation                                     `path:"@" ygotAnnotation:"true"`
	Interface  map[string]*OpenconfigInterfaces_Interfaces_Interface `path:"interface" module:"openconfig-interfaces"`
	ΛInterface []ygot.Annotation                                     `path:"@interface" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that OpenconfigInterfaces_Interfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigInterfaces_Interfaces) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// OpenconfigInterfaces_Interfaces struct. The keys of the list are populated from the input
// arguments.
func (t *OpenconfigInterfaces_Interfaces) NewInterface(Name string) (*OpenconfigInterfaces_Interfaces_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*OpenconfigInterfaces_Interfaces_Interface)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &OpenconfigInterfaces_Interfaces_Interface{
		Name: &Name,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the OpenconfigInterfaces_Interfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *OpenconfigInterfaces_Interfaces) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.Name = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from OpenconfigInterfaces_Interfaces.
//
// It initializes the field if not already initialized.
func (t *OpenconfigInterfaces_Interfaces) GetOrCreateInterfaceMap() map[string]*OpenconfigInterfaces_Interfaces_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*OpenconfigInterfaces_Interfaces_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver OpenconfigInterfaces_Interfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *OpenconfigInterfaces_Interfaces) GetOrCreateInterface(Name string) *OpenconfigInterfaces_Interfaces_Interface {

	key := Name

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of OpenconfigInterfaces_Interfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *OpenconfigInterfaces_Interfaces) GetInterface(Name string) *OpenconfigInterfaces_Interfaces_Interface {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// DeleteInterface deletes the value with the specified keys from
// the receiver OpenconfigInterfaces_Interfaces. If there is no such element, the function
// is a no-op.
func (t *OpenconfigInterfaces_Interfaces) DeleteInterface(Name string) {
	key := Name

	delete(t.Interface, key)
}

// AppendInterface appends the supplied OpenconfigInterfaces_Interfaces_Interface struct to the
// list Interface of OpenconfigInterfaces_Interfaces. If the key value(s) specified in
// the supplied OpenconfigInterfaces_Interfaces_Interface already exist in the list, an error is
// returned.
func (t *OpenconfigInterfaces_Interfaces) AppendInterface(v *OpenconfigInterfaces_Interfaces_Interface) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*OpenconfigInterfaces_Interfaces_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigInterfaces_Interfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpenconfigInterfaces_Interfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigInterfaces_Interfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpenconfigInterfaces_Interfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of OpenconfigInterfaces_Interfaces.
func (*OpenconfigInterfaces_Interfaces) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// OpenconfigInterfaces_Interfaces_Interface represents the /openconfig-interfaces/interfaces/interface YANG schema element.
type OpenconfigInterfaces_Interfaces_Interface struct {
	ΛMetadata         []ygot.Annotation                                           `path:"@" ygotAnnotation:"true"`
	Config            *OpenconfigInterfaces_Interfaces_Interface_Config           `path:"config" module:"openconfig-interfaces"`
	ΛConfig           []ygot.Annotation                                           `path:"@config" ygotAnnotation:"true"`
	Ethernet          *OpenconfigInterfaces_Interfaces_Interface_Ethernet         `path:"ethernet" module:"openconfig-if-ethernet"`
	ΛEthernet         []ygot.Annotation                                           `path:"@ethernet" ygotAnnotation:"true"`
	Name              *string                                                     `path:"name" module:"openconfig-interfaces"`
	ΛName             []ygot.Annotation                                           `path:"@name" ygotAnnotation:"true"`
	PenaltyBasedAied  *OpenconfigInterfaces_Interfaces_Interface_PenaltyBasedAied `path:"penalty-based-aied" module:"openconfig-interfaces"`
	ΛPenaltyBasedAied []ygot.Annotation                                           `path:"@penalty-based-aied" ygotAnnotation:"true"`
	State             *OpenconfigInterfaces_Interfaces_Interface_State            `path:"state" module:"openconfig-interfaces"`
	ΛState            []ygot.Annotation                                           `path:"@state" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that OpenconfigInterfaces_Interfaces_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigInterfaces_Interfaces_Interface) IsYANGGoStruct() {}

// GetOrCreateConfig retrieves the value of the Config field
// or returns the existing field if it already exists.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetOrCreateConfig() *OpenconfigInterfaces_Interfaces_Interface_Config {
	if t.Config != nil {
		return t.Config
	}
	t.Config = &OpenconfigInterfaces_Interfaces_Interface_Config{}
	return t.Config
}

// GetOrCreateEthernet retrieves the value of the Ethernet field
// or returns the existing field if it already exists.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetOrCreateEthernet() *OpenconfigInterfaces_Interfaces_Interface_Ethernet {
	if t.Ethernet != nil {
		return t.Ethernet
	}
	t.Ethernet = &OpenconfigInterfaces_Interfaces_Interface_Ethernet{}
	return t.Ethernet
}

// GetOrCreatePenaltyBasedAied retrieves the value of the PenaltyBasedAied field
// or returns the existing field if it already exists.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetOrCreatePenaltyBasedAied() *OpenconfigInterfaces_Interfaces_Interface_PenaltyBasedAied {
	if t.PenaltyBasedAied != nil {
		return t.PenaltyBasedAied
	}
	t.PenaltyBasedAied = &OpenconfigInterfaces_Interfaces_Interface_PenaltyBasedAied{}
	return t.PenaltyBasedAied
}

// GetOrCreateState retrieves the value of the State field
// or returns the existing field if it already exists.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetOrCreateState() *OpenconfigInterfaces_Interfaces_Interface_State {
	if t.State != nil {
		return t.State
	}
	t.State = &OpenconfigInterfaces_Interfaces_Interface_State{}
	return t.State
}

// GetConfig returns the value of the Config struct pointer
// from OpenconfigInterfaces_Interfaces_Interface. If the receiver or the field Config is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetConfig() *OpenconfigInterfaces_Interfaces_Interface_Config {
	if t != nil && t.Config != nil {
		return t.Config
	}
	return nil
}

// GetEthernet returns the value of the Ethernet struct pointer
// from OpenconfigInterfaces_Interfaces_Interface. If the receiver or the field Ethernet is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetEthernet() *OpenconfigInterfaces_Interfaces_Interface_Ethernet {
	if t != nil && t.Ethernet != nil {
		return t.Ethernet
	}
	return nil
}

// GetPenaltyBasedAied returns the value of the PenaltyBasedAied struct pointer
// from OpenconfigInterfaces_Interfaces_Interface. If the receiver or the field PenaltyBasedAied is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetPenaltyBasedAied() *OpenconfigInterfaces_Interfaces_Interface_PenaltyBasedAied {
	if t != nil && t.PenaltyBasedAied != nil {
		return t.PenaltyBasedAied
	}
	return nil
}

// GetState returns the value of the State struct pointer
// from OpenconfigInterfaces_Interfaces_Interface. If the receiver or the field State is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *OpenconfigInterfaces_Interfaces_Interface) GetState() *OpenconfigInterfaces_Interfaces_Interface_State {
	if t != nil && t.State != nil {
		return t.State
	}
	return nil
}

// ΛListKeyMap returns the keys of the OpenconfigInterfaces_Interfaces_Interface struct, which is a YANG list entry.
func (t *OpenconfigInterfaces_Interfaces_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigInterfaces_Interfaces_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpenconfigInterfaces_Interfaces_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigInterfaces_Interfaces_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpenconfigInterfaces_Interfaces_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of OpenconfigInterfaces_Interfaces_Interface.
func (*OpenconfigInterfaces_Interfaces_Interface) ΛBelongingModule() string {
	return "openconfig-interfaces"
}

// OpenconfigInterfaces_Interfaces_Interface_Config represents the /openconfig-interfaces/interfaces/interface/config YANG schema element.
type OpenconfigInterfaces_Interfaces_Interface_Config struct {
	ΛMetadata    []ygot.Annotation `path:"@" ygotAnnotation:"true"`
	Description  *string           `path:"description" module:"openconfig-interfaces"`
	ΛDescription []ygot.Annotation `path:"@description" ygotAnnotation:"true"`
	Name         *string           `path:"name" module:"openconfig-interfaces"`
	ΛName        []ygot.Annotation `path:"@name" ygotAnnotation:"true"`
}

// IsYANGGoStruct ensures that OpenconfigInterfaces_Interfaces_Interface_Config implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*OpenconfigInterfaces_Interfaces_Interface_Config) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigInterfaces_Interfaces_Interface_Config) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["OpenconfigInterfaces_Interfaces_Interface_Config"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *OpenconfigInterfaces_Interfaces_Interface_Config) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *OpenconfigInterfaces_Interfaces_Interface_Config) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of OpenconfigInterfaces_Interfaces_Interface_Config.
func (*OpenconfigInterfaces_Interfaces_Interface_Config) ΛBelongingModule() string {
	return "openconfig-interfaces"
}
