/*
Package native is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /usr/local/google/home/singhavnish/go/pkg/mod/github.com/openconfig/ygot@v0.33.0/genutil/names.go
using the following YANG input files:
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub3.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-types.yang
  - yang/vendor/cisco/xr/2431/cisco-semver.yang
  - yang/vendor/cisco/xr/2431/ietf-inet-types.yang

Imported modules were sourced from:
  - yang/vendor/cisco/xr/2431/...
*/
package native

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/entries/entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry struct {
	Address           *string                                 `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Age               *uint64                                 `path:"age" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EncapsulationType E_Cisco_IOS_XRIpv4ArpOper_IpArpBagEncap `path:"encapsulation-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Flag              E_Cisco_IOS_XRIpv4ArpOper_IpArpBagFlags `path:"flag" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddress   *string                                 `path:"hardware-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareLength    *uint8                                  `path:"hardware-length" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName     *string                                 `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MediaType         E_Cisco_IOS_XRIpv4ArpOper_IpArpBagMedia `path:"media-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	State             E_Cisco_IOS_XRIpv4ArpOper_IpArpBagState `path:"state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"address":        *t.Address,
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-events-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames struct {
	IdbEventsInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName `path:"idb-events-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) IsYANGGoStruct() {}

// NewIdbEventsInterfaceName creates a new entry in the IdbEventsInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) NewIdbEventsInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbEventsInterfaceName == nil {
		t.IdbEventsInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IdbEventsInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IdbEventsInterfaceName", key)
	}

	t.IdbEventsInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.IdbEventsInterfaceName[key], nil
}

// RenameIdbEventsInterfaceName renames an entry in the list IdbEventsInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) RenameIdbEventsInterfaceName(oldK, newK string) error {
	if _, ok := t.IdbEventsInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in IdbEventsInterfaceName", newK)
	}

	e, ok := t.IdbEventsInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IdbEventsInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.IdbEventsInterfaceName[newK] = e
	delete(t.IdbEventsInterfaceName, oldK)
	return nil
}

// GetOrCreateIdbEventsInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) GetOrCreateIdbEventsInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName {
	if t.IdbEventsInterfaceName == nil {
		t.IdbEventsInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName)
	}
	return t.IdbEventsInterfaceName
}

// GetOrCreateIdbEventsInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) GetOrCreateIdbEventsInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName {

	key := InterfaceName

	if v, ok := t.IdbEventsInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIdbEventsInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIdbEventsInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetIdbEventsInterfaceName retrieves the value with the specified key from
// the IdbEventsInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) GetIdbEventsInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.IdbEventsInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendIdbEventsInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName struct to the
// list IdbEventsInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) AppendIdbEventsInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbEventsInterfaceName == nil {
		t.IdbEventsInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName)
	}

	if _, ok := t.IdbEventsInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list IdbEventsInterfaceName %v", key)
	}

	t.IdbEventsInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-events-interface-names/idb-events-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName struct {
	EvtClassName  *string                                                                                           `path:"evt-class-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtEntry      []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry `path:"evt-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string                                                                                           `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-events-interface-names/idb-events-interface-name/evt-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry struct {
	EvtData      []uint32 `path:"evt-data" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtMany      *bool    `path:"evt-many" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtName      *string  `path:"evt-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtSticky    *bool    `path:"evt-sticky" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtTimestamp *string  `path:"evt-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtType      *uint8   `path:"evt-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames struct {
	IdbInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) IsYANGGoStruct() {}

// NewIdbInterfaceName creates a new entry in the IdbInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) NewIdbInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbInterfaceName == nil {
		t.IdbInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IdbInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IdbInterfaceName", key)
	}

	t.IdbInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.IdbInterfaceName[key], nil
}

// RenameIdbInterfaceName renames an entry in the list IdbInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) RenameIdbInterfaceName(oldK, newK string) error {
	if _, ok := t.IdbInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in IdbInterfaceName", newK)
	}

	e, ok := t.IdbInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IdbInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.IdbInterfaceName[newK] = e
	delete(t.IdbInterfaceName, oldK)
	return nil
}

// GetOrCreateIdbInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) GetOrCreateIdbInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName {
	if t.IdbInterfaceName == nil {
		t.IdbInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName)
	}
	return t.IdbInterfaceName
}

// GetOrCreateIdbInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) GetOrCreateIdbInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName {

	key := InterfaceName

	if v, ok := t.IdbInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIdbInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIdbInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetIdbInterfaceName retrieves the value with the specified key from
// the IdbInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) GetIdbInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.IdbInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendIdbInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName struct to the
// list IdbInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) AppendIdbInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbInterfaceName == nil {
		t.IdbInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName)
	}

	if _, ok := t.IdbInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list IdbInterfaceName %v", key)
	}

	t.IdbInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName struct {
	BfdMinInterval                    *uint32                                                                                     `path:"bfd-min-interval" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BfdMultiplier                     *uint8                                                                                      `path:"bfd-multiplier" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BfdSrcIpAddr                      *string                                                                                     `path:"bfd-src-ip-addr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BroadcastDisabled                 *bool                                                                                       `path:"broadcast-disabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CacheLimit                        *uint32                                                                                     `path:"cache-limit" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CapsulationState                  *uint32                                                                                     `path:"capsulation-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientId                          *uint32                                                                                     `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientResyncTime                  *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime `path:"client-resync-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CompleteGleanCount                *uint32                                                                                     `path:"complete-glean-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CompleteProtocolCount             *uint32                                                                                     `path:"complete-protocol-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjTimeout                    *uint32                                                                                     `path:"drop-adj-timeout" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DroppedGleanCount                 *uint32                                                                                     `path:"dropped-glean-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DroppedProtocolCount              *uint32                                                                                     `path:"dropped-protocol-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddressKnown              *bool                                                                                       `path:"hardware-address-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbEventHistory                   *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory  `path:"idb-event-history" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbFlag                           *uint32                                                                                     `path:"idb-flag" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbFlagExt                        *uint32                                                                                     `path:"idb-flag-ext" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName                  *string                                                                                     `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbIpAddress                      *string                                                                                     `path:"idb-ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbTimeout                        *uint32                                                                                     `path:"idb-timeout" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IncompleteGleanCount              *uint32                                                                                     `path:"incomplete-glean-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName                     *string                                                                                     `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4CapsulationKnown              *bool                                                                                       `path:"ipv4-capsulation-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsComplete                        *bool                                                                                       `path:"is-complete" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsDynamicLearningEnabled          *bool                                                                                       `path:"is-dynamic-learning-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsDynamicLearningLocalEnabled     *bool                                                                                       `path:"is-dynamic-learning-local-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsDynamicLearningSolicitedEnabled *bool                                                                                       `path:"is-dynamic-learning-solicited-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsIdbForwardReferenced            *bool                                                                                       `path:"is-idb-forward-referenced" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsIpv4Unnumbered                  *bool                                                                                       `path:"is-ipv4-unnumbered" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsLocalProxyConfigured            *bool                                                                                       `path:"is-local-proxy-configured" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsProxyConfigured                 *bool                                                                                       `path:"is-proxy-configured" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsProxyEnabled                    *bool                                                                                       `path:"is-proxy-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsPurgeDelayConfigured            *bool                                                                                       `path:"is-purge-delay-configured" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsUsingSpio                       *bool                                                                                       `path:"is-using-spio" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsVirtual                         *bool                                                                                       `path:"is-virtual" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MediaKnown                        *bool                                                                                       `path:"media-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MplsCapsulationKnown              *bool                                                                                       `path:"mpls-capsulation-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OperProgress                      E_Cisco_IOS_XRIpv4ArpOper_ArpImOperBag                                                      `path:"oper-progress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProbeInterval                     *uint32                                                                                     `path:"probe-interval" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProbeRetries                      *uint8                                                                                      `path:"probe-retries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PurgeDelay                        *uint32                                                                                     `path:"purge-delay" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SpioAttachError                   *uint32                                                                                     `path:"spio-attach-error" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrgRole                           *uint8                                                                                      `path:"srg-role" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VlanidKnown                       *bool                                                                                       `path:"vlanid-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfId                             *uint32                                                                                     `path:"vrf-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName                           *string                                                                                     `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) IsYANGGoStruct() {}

// GetOrCreateClientResyncTime retrieves the value of the ClientResyncTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetOrCreateClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime {
	if t.ClientResyncTime != nil {
		return t.ClientResyncTime
	}
	t.ClientResyncTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime{}
	return t.ClientResyncTime
}

// GetOrCreateIdbEventHistory retrieves the value of the IdbEventHistory field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetOrCreateIdbEventHistory() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory {
	if t.IdbEventHistory != nil {
		return t.IdbEventHistory
	}
	t.IdbEventHistory = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory{}
	return t.IdbEventHistory
}

// GetClientResyncTime returns the value of the ClientResyncTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName. If the receiver or the field ClientResyncTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime {
	if t != nil && t.ClientResyncTime != nil {
		return t.ClientResyncTime
	}
	return nil
}

// GetIdbEventHistory returns the value of the IdbEventHistory struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName. If the receiver or the field IdbEventHistory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetIdbEventHistory() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory {
	if t != nil && t.IdbEventHistory != nil {
		return t.IdbEventHistory
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name/client-resync-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name/idb-event-history YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory struct {
	EvtClassName *string                                                                                               `path:"evt-class-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtEntry     []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry `path:"evt-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name/idb-event-history/evt-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry struct {
	EvtData      []uint32 `path:"evt-data" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtMany      *bool    `path:"evt-many" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtName      *string  `path:"evt-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtSticky    *bool    `path:"evt-sticky" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtTimestamp *string  `path:"evt-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtType      *uint8   `path:"evt-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-all YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-all/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry struct {
	DsTaddress       *string `path:"ds-taddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DstMac           *string `path:"dst-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Mode             *int32  `path:"mode" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrCaddress       *string `path:"sr-caddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrcMac           *string `path:"src-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames struct {
	PacketHistoryInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName `path:"packet-history-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) IsYANGGoStruct() {}

// NewPacketHistoryInterfaceName creates a new entry in the PacketHistoryInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) NewPacketHistoryInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PacketHistoryInterfaceName == nil {
		t.PacketHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PacketHistoryInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PacketHistoryInterfaceName", key)
	}

	t.PacketHistoryInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.PacketHistoryInterfaceName[key], nil
}

// RenamePacketHistoryInterfaceName renames an entry in the list PacketHistoryInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) RenamePacketHistoryInterfaceName(oldK, newK string) error {
	if _, ok := t.PacketHistoryInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in PacketHistoryInterfaceName", newK)
	}

	e, ok := t.PacketHistoryInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PacketHistoryInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.PacketHistoryInterfaceName[newK] = e
	delete(t.PacketHistoryInterfaceName, oldK)
	return nil
}

// GetOrCreatePacketHistoryInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) GetOrCreatePacketHistoryInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName {
	if t.PacketHistoryInterfaceName == nil {
		t.PacketHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName)
	}
	return t.PacketHistoryInterfaceName
}

// GetOrCreatePacketHistoryInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) GetOrCreatePacketHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName {

	key := InterfaceName

	if v, ok := t.PacketHistoryInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPacketHistoryInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePacketHistoryInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetPacketHistoryInterfaceName retrieves the value with the specified key from
// the PacketHistoryInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) GetPacketHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.PacketHistoryInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendPacketHistoryInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName struct to the
// list PacketHistoryInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) AppendPacketHistoryInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PacketHistoryInterfaceName == nil {
		t.PacketHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName)
	}

	if _, ok := t.PacketHistoryInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list PacketHistoryInterfaceName %v", key)
	}

	t.PacketHistoryInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-interface-names/packet-history-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName struct {
	ArpEntry      []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string                                                                                                   `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-interface-names/packet-history-interface-name/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry struct {
	DsTaddress       *string `path:"ds-taddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DstMac           *string `path:"dst-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Mode             *int32  `path:"mode" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrCaddress       *string `path:"sr-caddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrcMac           *string `path:"src-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-client YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-client/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry struct {
	ClientId               *int32                                               `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState             *int32                                               `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName       *string                                              `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address            *string                                              `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress             *string                                              `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp          *uint64                                              `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestCount *uint32                                              `path:"resolution-request-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Status                 E_Cisco_IOS_XRIpv4ArpOper_ArpResolutionHistoryStatus `path:"status" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-dynamic YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-dynamic/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry struct {
	ClientId               *int32                                               `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState             *int32                                               `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName       *string                                              `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address            *string                                              `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress             *string                                              `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp          *uint64                                              `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestCount *uint32                                              `path:"resolution-request-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Status                 E_Cisco_IOS_XRIpv4ArpOper_ArpResolutionHistoryStatus `path:"status" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics struct {
	InputPacketDropCount   *uint64                                                                          `path:"input-packet-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LastInputPulseTime     *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime `path:"last-input-pulse-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LastPuntPulseTime      *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime  `path:"last-punt-pulse-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PuntPacketDropCount    *uint64                                                                          `path:"punt-packet-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QueueMsg               []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg         `path:"queue-msg" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalDropCount         *uint64                                                                          `path:"total-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	UnknownPacketDropCount *uint64                                                                          `path:"unknown-packet-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) IsYANGGoStruct() {}

// GetOrCreateLastInputPulseTime retrieves the value of the LastInputPulseTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetOrCreateLastInputPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime {
	if t.LastInputPulseTime != nil {
		return t.LastInputPulseTime
	}
	t.LastInputPulseTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime{}
	return t.LastInputPulseTime
}

// GetOrCreateLastPuntPulseTime retrieves the value of the LastPuntPulseTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetOrCreateLastPuntPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime {
	if t.LastPuntPulseTime != nil {
		return t.LastPuntPulseTime
	}
	t.LastPuntPulseTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime{}
	return t.LastPuntPulseTime
}

// GetLastInputPulseTime returns the value of the LastInputPulseTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics. If the receiver or the field LastInputPulseTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetLastInputPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime {
	if t != nil && t.LastInputPulseTime != nil {
		return t.LastInputPulseTime
	}
	return nil
}

// GetLastPuntPulseTime returns the value of the LastPuntPulseTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics. If the receiver or the field LastPuntPulseTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetLastPuntPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime {
	if t != nil && t.LastPuntPulseTime != nil {
		return t.LastPuntPulseTime
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/last-input-pulse-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/last-punt-pulse-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/queue-msg YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg struct {
	CurrentElementInfo *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo `path:"current-element-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OldElementInfo     *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo     `path:"old-element-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadName         *string                                                                                   `path:"thread-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) IsYANGGoStruct() {}

// GetOrCreateCurrentElementInfo retrieves the value of the CurrentElementInfo field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetOrCreateCurrentElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo {
	if t.CurrentElementInfo != nil {
		return t.CurrentElementInfo
	}
	t.CurrentElementInfo = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo{}
	return t.CurrentElementInfo
}

// GetOrCreateOldElementInfo retrieves the value of the OldElementInfo field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetOrCreateOldElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo {
	if t.OldElementInfo != nil {
		return t.OldElementInfo
	}
	t.OldElementInfo = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo{}
	return t.OldElementInfo
}

// GetCurrentElementInfo returns the value of the CurrentElementInfo struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg. If the receiver or the field CurrentElementInfo is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetCurrentElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo {
	if t != nil && t.CurrentElementInfo != nil {
		return t.CurrentElementInfo
	}
	return nil
}

// GetOldElementInfo returns the value of the OldElementInfo struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg. If the receiver or the field OldElementInfo is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetOldElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo {
	if t != nil && t.OldElementInfo != nil {
		return t.OldElementInfo
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/queue-msg/current-element-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo struct {
	DqCount           *uint32 `path:"dq-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MsgsEnqueuedCount *uint32 `path:"msgs-enqueued-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoQCount          *uint32 `path:"no-q-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeakQSize         *uint32 `path:"peak-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseRecvdCount   *uint32 `path:"pulse-recvd-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseSentCount    *uint32 `path:"pulse-sent-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QblockedCount     *uint32 `path:"qblocked-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QreleasedCount    *uint32 `path:"qreleased-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SelfPulseCount    *uint32 `path:"self-pulse-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadQSize       *uint32 `path:"thread-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/queue-msg/old-element-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo struct {
	DqCount           *uint32 `path:"dq-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MsgsEnqueuedCount *uint32 `path:"msgs-enqueued-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoQCount          *uint32 `path:"no-q-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeakQSize         *uint32 `path:"peak-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseRecvdCount   *uint32 `path:"pulse-recvd-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseSentCount    *uint32 `path:"pulse-sent-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QblockedCount     *uint32 `path:"qblocked-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QreleasedCount    *uint32 `path:"qreleased-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SelfPulseCount    *uint32 `path:"self-pulse-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadQSize       *uint32 `path:"thread-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-interfaces YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces struct {
	TrafficInterface map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface `path:"traffic-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) IsYANGGoStruct() {}

// NewTrafficInterface creates a new entry in the TrafficInterface list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) NewTrafficInterface(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficInterface == nil {
		t.TrafficInterface = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrafficInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrafficInterface", key)
	}

	t.TrafficInterface[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface{
		InterfaceName: &InterfaceName,
	}

	return t.TrafficInterface[key], nil
}

// RenameTrafficInterface renames an entry in the list TrafficInterface within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) RenameTrafficInterface(oldK, newK string) error {
	if _, ok := t.TrafficInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TrafficInterface", newK)
	}

	e, ok := t.TrafficInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrafficInterface", oldK)
	}
	e.InterfaceName = &newK

	t.TrafficInterface[newK] = e
	delete(t.TrafficInterface, oldK)
	return nil
}

// GetOrCreateTrafficInterfaceMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) GetOrCreateTrafficInterfaceMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface {
	if t.TrafficInterface == nil {
		t.TrafficInterface = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface)
	}
	return t.TrafficInterface
}

// GetOrCreateTrafficInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) GetOrCreateTrafficInterface(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface {

	key := InterfaceName

	if v, ok := t.TrafficInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrafficInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrafficInterface got unexpected error: %v", err))
	}
	return v
}

// GetTrafficInterface retrieves the value with the specified key from
// the TrafficInterface map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) GetTrafficInterface(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.TrafficInterface[key]; ok {
		return lm
	}
	return nil
}

// AppendTrafficInterface appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface struct to the
// list TrafficInterface of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) AppendTrafficInterface(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficInterface == nil {
		t.TrafficInterface = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface)
	}

	if _, ok := t.TrafficInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TrafficInterface %v", key)
	}

	t.TrafficInterface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-interfaces/traffic-interface YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName                 *string `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-node YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-vrfs YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs struct {
	TrafficVrf map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf `path:"traffic-vrf" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) IsYANGGoStruct() {}

// NewTrafficVrf creates a new entry in the TrafficVrf list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) NewTrafficVrf(VrfName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficVrf == nil {
		t.TrafficVrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrafficVrf[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrafficVrf", key)
	}

	t.TrafficVrf[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf{
		VrfName: &VrfName,
	}

	return t.TrafficVrf[key], nil
}

// RenameTrafficVrf renames an entry in the list TrafficVrf within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) RenameTrafficVrf(oldK, newK string) error {
	if _, ok := t.TrafficVrf[newK]; ok {
		return fmt.Errorf("key %v already exists in TrafficVrf", newK)
	}

	e, ok := t.TrafficVrf[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrafficVrf", oldK)
	}
	e.VrfName = &newK

	t.TrafficVrf[newK] = e
	delete(t.TrafficVrf, oldK)
	return nil
}

// GetOrCreateTrafficVrfMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) GetOrCreateTrafficVrfMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf {
	if t.TrafficVrf == nil {
		t.TrafficVrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf)
	}
	return t.TrafficVrf
}

// GetOrCreateTrafficVrf retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) GetOrCreateTrafficVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf {

	key := VrfName

	if v, ok := t.TrafficVrf[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrafficVrf(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrafficVrf got unexpected error: %v", err))
	}
	return v
}

// GetTrafficVrf retrieves the value with the specified key from
// the TrafficVrf map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) GetTrafficVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.TrafficVrf[key]; ok {
		return lm
	}
	return nil
}

// AppendTrafficVrf appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf struct to the
// list TrafficVrf of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) AppendTrafficVrf(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficVrf == nil {
		t.TrafficVrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf)
	}

	if _, ok := t.TrafficVrf[key]; ok {
		return fmt.Errorf("duplicate key for list TrafficVrf %v", key)
	}

	t.TrafficVrf[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-vrfs/traffic-vrf YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName                       *string `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery struct {
	Nodes *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes `path:"nodes" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) IsYANGGoStruct() {}

// GetOrCreateNodes retrieves the value of the Nodes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) GetOrCreateNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes {
	if t.Nodes != nil {
		return t.Nodes
	}
	t.Nodes = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes{}
	return t.Nodes
}

// GetNodes returns the value of the Nodes struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery. If the receiver or the field Nodes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) GetNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes {
	if t != nil && t.Nodes != nil {
		return t.Nodes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes struct {
	Node map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node `path:"node" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) IsYANGGoStruct() {}

// NewNode creates a new entry in the Node list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) NewNode(NodeName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node)
	}

	key := NodeName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Node[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Node", key)
	}

	t.Node[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node{
		NodeName: &NodeName,
	}

	return t.Node[key], nil
}

// RenameNode renames an entry in the list Node within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) RenameNode(oldK, newK string) error {
	if _, ok := t.Node[newK]; ok {
		return fmt.Errorf("key %v already exists in Node", newK)
	}

	e, ok := t.Node[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Node", oldK)
	}
	e.NodeName = &newK

	t.Node[newK] = e
	delete(t.Node, oldK)
	return nil
}

// GetOrCreateNodeMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) GetOrCreateNodeMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node {
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node)
	}
	return t.Node
}

// GetOrCreateNode retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) GetOrCreateNode(NodeName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node {

	key := NodeName

	if v, ok := t.Node[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNode(NodeName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNode got unexpected error: %v", err))
	}
	return v
}

// GetNode retrieves the value with the specified key from
// the Node map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) GetNode(NodeName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node {

	if t == nil {
		return nil
	}

	key := NodeName

	if lm, ok := t.Node[key]; ok {
		return lm
	}
	return nil
}

// AppendNode appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node struct to the
// list Node of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) AppendNode(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) error {
	if v.NodeName == nil {
		return fmt.Errorf("invalid nil key received for NodeName")
	}

	key := *v.NodeName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node)
	}

	if _, ok := t.Node[key]; ok {
		return fmt.Errorf("duplicate key for list Node %v", key)
	}

	t.Node[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node struct {
	BundleInterfaces   *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces   `path:"bundle-interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	BundleNodes        *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes        `path:"bundle-nodes" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Interfaces         *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces         `path:"interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdVirtualRouters   *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters   `path:"nd-virtual-routers" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NeighborInterfaces *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces `path:"neighbor-interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NeighborSummary    *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary    `path:"neighbor-summary" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NodeName           *string                                                                 `path:"node-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SlaacInterfaces    *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces    `path:"slaac-interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) IsYANGGoStruct() {}

// GetOrCreateBundleInterfaces retrieves the value of the BundleInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateBundleInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces {
	if t.BundleInterfaces != nil {
		return t.BundleInterfaces
	}
	t.BundleInterfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces{}
	return t.BundleInterfaces
}

// GetOrCreateBundleNodes retrieves the value of the BundleNodes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateBundleNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes {
	if t.BundleNodes != nil {
		return t.BundleNodes
	}
	t.BundleNodes = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes{}
	return t.BundleNodes
}

// GetOrCreateInterfaces retrieves the value of the Interfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces {
	if t.Interfaces != nil {
		return t.Interfaces
	}
	t.Interfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces{}
	return t.Interfaces
}

// GetOrCreateNdVirtualRouters retrieves the value of the NdVirtualRouters field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateNdVirtualRouters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters {
	if t.NdVirtualRouters != nil {
		return t.NdVirtualRouters
	}
	t.NdVirtualRouters = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters{}
	return t.NdVirtualRouters
}

// GetOrCreateNeighborInterfaces retrieves the value of the NeighborInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateNeighborInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces {
	if t.NeighborInterfaces != nil {
		return t.NeighborInterfaces
	}
	t.NeighborInterfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces{}
	return t.NeighborInterfaces
}

// GetOrCreateNeighborSummary retrieves the value of the NeighborSummary field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateNeighborSummary() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary {
	if t.NeighborSummary != nil {
		return t.NeighborSummary
	}
	t.NeighborSummary = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary{}
	return t.NeighborSummary
}

// GetOrCreateSlaacInterfaces retrieves the value of the SlaacInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateSlaacInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces {
	if t.SlaacInterfaces != nil {
		return t.SlaacInterfaces
	}
	t.SlaacInterfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces{}
	return t.SlaacInterfaces
}

// GetBundleInterfaces returns the value of the BundleInterfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field BundleInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetBundleInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces {
	if t != nil && t.BundleInterfaces != nil {
		return t.BundleInterfaces
	}
	return nil
}

// GetBundleNodes returns the value of the BundleNodes struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field BundleNodes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetBundleNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes {
	if t != nil && t.BundleNodes != nil {
		return t.BundleNodes
	}
	return nil
}

// GetInterfaces returns the value of the Interfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field Interfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces {
	if t != nil && t.Interfaces != nil {
		return t.Interfaces
	}
	return nil
}

// GetNdVirtualRouters returns the value of the NdVirtualRouters struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field NdVirtualRouters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetNdVirtualRouters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters {
	if t != nil && t.NdVirtualRouters != nil {
		return t.NdVirtualRouters
	}
	return nil
}

// GetNeighborInterfaces returns the value of the NeighborInterfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field NeighborInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetNeighborInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces {
	if t != nil && t.NeighborInterfaces != nil {
		return t.NeighborInterfaces
	}
	return nil
}

// GetNeighborSummary returns the value of the NeighborSummary struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field NeighborSummary is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetNeighborSummary() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary {
	if t != nil && t.NeighborSummary != nil {
		return t.NeighborSummary
	}
	return nil
}

// GetSlaacInterfaces returns the value of the SlaacInterfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field SlaacInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetSlaacInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces {
	if t != nil && t.SlaacInterfaces != nil {
		return t.SlaacInterfaces
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeName == nil {
		return nil, fmt.Errorf("nil value for key NodeName")
	}

	return map[string]interface{}{
		"node-name": *t.NodeName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces struct {
	BundleInterface map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface `path:"bundle-interface" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) IsYANGGoStruct() {}

// NewBundleInterface creates a new entry in the BundleInterface list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) NewBundleInterface(InterfaceName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BundleInterface == nil {
		t.BundleInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BundleInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BundleInterface", key)
	}

	t.BundleInterface[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface{
		InterfaceName: &InterfaceName,
	}

	return t.BundleInterface[key], nil
}

// RenameBundleInterface renames an entry in the list BundleInterface within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) RenameBundleInterface(oldK, newK string) error {
	if _, ok := t.BundleInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in BundleInterface", newK)
	}

	e, ok := t.BundleInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BundleInterface", oldK)
	}
	e.InterfaceName = &newK

	t.BundleInterface[newK] = e
	delete(t.BundleInterface, oldK)
	return nil
}

// GetOrCreateBundleInterfaceMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) GetOrCreateBundleInterfaceMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface {
	if t.BundleInterface == nil {
		t.BundleInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface)
	}
	return t.BundleInterface
}

// GetOrCreateBundleInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) GetOrCreateBundleInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface {

	key := InterfaceName

	if v, ok := t.BundleInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBundleInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBundleInterface got unexpected error: %v", err))
	}
	return v
}

// GetBundleInterface retrieves the value with the specified key from
// the BundleInterface map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) GetBundleInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.BundleInterface[key]; ok {
		return lm
	}
	return nil
}

// AppendBundleInterface appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface struct to the
// list BundleInterface of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) AppendBundleInterface(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BundleInterface == nil {
		t.BundleInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface)
	}

	if _, ok := t.BundleInterface[key]; ok {
		return fmt.Errorf("duplicate key for list BundleInterface %v", key)
	}

	t.BundleInterface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces/bundle-interface YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface struct {
	Etype               *uint32                                                                                               `path:"etype" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	GlobalAddress       []*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress `path:"global-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Iftype              *uint32                                                                                               `path:"iftype" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	InterfaceName       *string                                                                                               `path:"interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsInterfaceEnabled  *bool                                                                                                 `path:"is-interface-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsIpv6Enabled       *bool                                                                                                 `path:"is-ipv6-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsMplsEnabled       *bool                                                                                                 `path:"is-mpls-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	LocalAddress        *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress    `path:"local-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MacAddr             *string                                                                                               `path:"mac-addr" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MacAddrSize         *uint32                                                                                               `path:"mac-addr-size" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MemberLink          []uint32                                                                                              `path:"member-link" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MemberNode          []*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode    `path:"member-node" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Mtu                 *uint32                                                                                               `path:"mtu" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdParameters        *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters    `path:"nd-parameters" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ParentInterfaceName *string                                                                                               `path:"parent-interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	VlanTag             *uint16                                                                                               `path:"vlan-tag" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) IsYANGGoStruct() {
}

// GetOrCreateLocalAddress retrieves the value of the LocalAddress field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetOrCreateLocalAddress() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress {
	if t.LocalAddress != nil {
		return t.LocalAddress
	}
	t.LocalAddress = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress{}
	return t.LocalAddress
}

// GetOrCreateNdParameters retrieves the value of the NdParameters field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetOrCreateNdParameters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters {
	if t.NdParameters != nil {
		return t.NdParameters
	}
	t.NdParameters = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters{}
	return t.NdParameters
}

// GetLocalAddress returns the value of the LocalAddress struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface. If the receiver or the field LocalAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetLocalAddress() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress {
	if t != nil && t.LocalAddress != nil {
		return t.LocalAddress
	}
	return nil
}

// GetNdParameters returns the value of the NdParameters struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface. If the receiver or the field NdParameters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetNdParameters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters {
	if t != nil && t.NdParameters != nil {
		return t.NdParameters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}
