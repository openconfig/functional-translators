/*
Package native is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /usr/local/google/home/singhavnish/go/pkg/mod/github.com/openconfig/ygot@v0.33.0/genutil/names.go
using the following YANG input files:
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub3.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-types.yang
  - yang/vendor/cisco/xr/2431/cisco-semver.yang
  - yang/vendor/cisco/xr/2431/ietf-inet-types.yang

Imported modules were sourced from:
  - yang/vendor/cisco/xr/2431/...
*/
package native

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &CiscoDevice{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// CiscoDevice represents the /CiscoDevice YANG schema element.
type CiscoDevice struct {
	Arp               *Cisco_IOS_XRIpv4ArpOper_Arp              `path:"arp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpGmp            *Cisco_IOS_XRIpv4ArpOper_ArpGmp           `path:"arp-gmp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv6NodeDiscovery *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery `path:"ipv6-node-discovery" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that CiscoDevice implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*CiscoDevice) IsYANGGoStruct() {}

// GetOrCreateArp retrieves the value of the Arp field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateArp() *Cisco_IOS_XRIpv4ArpOper_Arp {
	if t.Arp != nil {
		return t.Arp
	}
	t.Arp = &Cisco_IOS_XRIpv4ArpOper_Arp{}
	return t.Arp
}

// GetOrCreateArpGmp retrieves the value of the ArpGmp field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateArpGmp() *Cisco_IOS_XRIpv4ArpOper_ArpGmp {
	if t.ArpGmp != nil {
		return t.ArpGmp
	}
	t.ArpGmp = &Cisco_IOS_XRIpv4ArpOper_ArpGmp{}
	return t.ArpGmp
}

// GetOrCreateIpv6NodeDiscovery retrieves the value of the Ipv6NodeDiscovery field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateIpv6NodeDiscovery() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery {
	if t.Ipv6NodeDiscovery != nil {
		return t.Ipv6NodeDiscovery
	}
	t.Ipv6NodeDiscovery = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery{}
	return t.Ipv6NodeDiscovery
}

// GetArp returns the value of the Arp struct pointer
// from CiscoDevice. If the receiver or the field Arp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetArp() *Cisco_IOS_XRIpv4ArpOper_Arp {
	if t != nil && t.Arp != nil {
		return t.Arp
	}
	return nil
}

// GetArpGmp returns the value of the ArpGmp struct pointer
// from CiscoDevice. If the receiver or the field ArpGmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetArpGmp() *Cisco_IOS_XRIpv4ArpOper_ArpGmp {
	if t != nil && t.ArpGmp != nil {
		return t.ArpGmp
	}
	return nil
}

// GetIpv6NodeDiscovery returns the value of the Ipv6NodeDiscovery struct pointer
// from CiscoDevice. If the receiver or the field Ipv6NodeDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetIpv6NodeDiscovery() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery {
	if t != nil && t.Ipv6NodeDiscovery != nil {
		return t.Ipv6NodeDiscovery
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *CiscoDevice) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["CiscoDevice"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *CiscoDevice) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *CiscoDevice) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of CiscoDevice.
func (*CiscoDevice) ΛBelongingModule() string {
	return ""
}

// Cisco_IOS_XRIpv4ArpOper_Arp represents the /Cisco-IOS-XR-ipv4-arp-oper/arp YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp struct {
	Nodes *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes `path:"nodes" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp) IsYANGGoStruct() {}

// GetOrCreateNodes retrieves the value of the Nodes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) GetOrCreateNodes() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes {
	if t.Nodes != nil {
		return t.Nodes
	}
	t.Nodes = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes{}
	return t.Nodes
}

// GetNodes returns the value of the Nodes struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp. If the receiver or the field Nodes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) GetNodes() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes {
	if t != nil && t.Nodes != nil {
		return t.Nodes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp.
func (*Cisco_IOS_XRIpv4ArpOper_Arp) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp struct {
	VrfInfos *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos `path:"vrf-infos" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Vrfs     *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs     `path:"vrfs" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp) IsYANGGoStruct() {}

// GetOrCreateVrfInfos retrieves the value of the VrfInfos field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetOrCreateVrfInfos() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos {
	if t.VrfInfos != nil {
		return t.VrfInfos
	}
	t.VrfInfos = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos{}
	return t.VrfInfos
}

// GetOrCreateVrfs retrieves the value of the Vrfs field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetOrCreateVrfs() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs {
	if t.Vrfs != nil {
		return t.Vrfs
	}
	t.Vrfs = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs{}
	return t.Vrfs
}

// GetVrfInfos returns the value of the VrfInfos struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp. If the receiver or the field VrfInfos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetVrfInfos() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos {
	if t != nil && t.VrfInfos != nil {
		return t.VrfInfos
	}
	return nil
}

// GetVrfs returns the value of the Vrfs struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp. If the receiver or the field Vrfs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetVrfs() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs {
	if t != nil && t.Vrfs != nil {
		return t.Vrfs
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrf-infos YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos struct {
	VrfInfo map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo `path:"vrf-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) IsYANGGoStruct() {}

// NewVrfInfo creates a new entry in the VrfInfo list of the
// Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) NewVrfInfo(VrfName string) (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrfInfo == nil {
		t.VrfInfo = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrfInfo[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrfInfo", key)
	}

	t.VrfInfo[key] = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo{
		VrfName: &VrfName,
	}

	return t.VrfInfo[key], nil
}

// RenameVrfInfo renames an entry in the list VrfInfo within
// the Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) RenameVrfInfo(oldK, newK string) error {
	if _, ok := t.VrfInfo[newK]; ok {
		return fmt.Errorf("key %v already exists in VrfInfo", newK)
	}

	e, ok := t.VrfInfo[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrfInfo", oldK)
	}
	e.VrfName = &newK

	t.VrfInfo[newK] = e
	delete(t.VrfInfo, oldK)
	return nil
}

// GetOrCreateVrfInfoMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) GetOrCreateVrfInfoMap() map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo {
	if t.VrfInfo == nil {
		t.VrfInfo = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo)
	}
	return t.VrfInfo
}

// GetOrCreateVrfInfo retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) GetOrCreateVrfInfo(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo {

	key := VrfName

	if v, ok := t.VrfInfo[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrfInfo(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrfInfo got unexpected error: %v", err))
	}
	return v
}

// GetVrfInfo retrieves the value with the specified key from
// the VrfInfo map field of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) GetVrfInfo(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.VrfInfo[key]; ok {
		return lm
	}
	return nil
}

// AppendVrfInfo appends the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo struct to the
// list VrfInfo of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) AppendVrfInfo(v *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrfInfo == nil {
		t.VrfInfo = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo)
	}

	if _, ok := t.VrfInfo[key]; ok {
		return fmt.Errorf("duplicate key for list VrfInfo %v", key)
	}

	t.VrfInfo[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrf-infos/vrf-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo struct {
	RsiHandle     *uint32 `path:"rsi-handle" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RsiHandleHigh *uint32 `path:"rsi-handle-high" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TableId       *uint32 `path:"table-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfIdNumber   *uint32 `path:"vrf-id-number" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName       *string `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfNameXr     *string `path:"vrf-name-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs struct {
	Vrf map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf `path:"vrf" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) IsYANGGoStruct() {}

// NewVrf creates a new entry in the Vrf list of the
// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) NewVrf(VrfName string) (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vrf[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vrf", key)
	}

	t.Vrf[key] = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf{
		VrfName: &VrfName,
	}

	return t.Vrf[key], nil
}

// RenameVrf renames an entry in the list Vrf within
// the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) RenameVrf(oldK, newK string) error {
	if _, ok := t.Vrf[newK]; ok {
		return fmt.Errorf("key %v already exists in Vrf", newK)
	}

	e, ok := t.Vrf[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vrf", oldK)
	}
	e.VrfName = &newK

	t.Vrf[newK] = e
	delete(t.Vrf, oldK)
	return nil
}

// GetOrCreateVrfMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) GetOrCreateVrfMap() map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf {
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf)
	}
	return t.Vrf
}

// GetOrCreateVrf retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) GetOrCreateVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf {

	key := VrfName

	if v, ok := t.Vrf[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrf(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrf got unexpected error: %v", err))
	}
	return v
}

// GetVrf retrieves the value with the specified key from
// the Vrf map field of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) GetVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.Vrf[key]; ok {
		return lm
	}
	return nil
}

// AppendVrf appends the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf struct to the
// list Vrf of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) AppendVrf(v *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf)
	}

	if _, ok := t.Vrf[key]; ok {
		return fmt.Errorf("duplicate key for list Vrf %v", key)
	}

	t.Vrf[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf struct {
	ConfiguredIpAddresses          *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses          `path:"configured-ip-addresses" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceConfiguredIpAddresses *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses `path:"interface-configured-ip-addresses" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Routes                         *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes                         `path:"routes" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName                        *string                                                                 `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) IsYANGGoStruct() {}

// GetOrCreateConfiguredIpAddresses retrieves the value of the ConfiguredIpAddresses field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetOrCreateConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses {
	if t.ConfiguredIpAddresses != nil {
		return t.ConfiguredIpAddresses
	}
	t.ConfiguredIpAddresses = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses{}
	return t.ConfiguredIpAddresses
}

// GetOrCreateInterfaceConfiguredIpAddresses retrieves the value of the InterfaceConfiguredIpAddresses field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetOrCreateInterfaceConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses {
	if t.InterfaceConfiguredIpAddresses != nil {
		return t.InterfaceConfiguredIpAddresses
	}
	t.InterfaceConfiguredIpAddresses = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses{}
	return t.InterfaceConfiguredIpAddresses
}

// GetOrCreateRoutes retrieves the value of the Routes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetOrCreateRoutes() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes {
	if t.Routes != nil {
		return t.Routes
	}
	t.Routes = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes{}
	return t.Routes
}

// GetConfiguredIpAddresses returns the value of the ConfiguredIpAddresses struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf. If the receiver or the field ConfiguredIpAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses {
	if t != nil && t.ConfiguredIpAddresses != nil {
		return t.ConfiguredIpAddresses
	}
	return nil
}

// GetInterfaceConfiguredIpAddresses returns the value of the InterfaceConfiguredIpAddresses struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf. If the receiver or the field InterfaceConfiguredIpAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetInterfaceConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses {
	if t != nil && t.InterfaceConfiguredIpAddresses != nil {
		return t.InterfaceConfiguredIpAddresses
	}
	return nil
}

// GetRoutes returns the value of the Routes struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf. If the receiver or the field Routes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetRoutes() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes {
	if t != nil && t.Routes != nil {
		return t.Routes
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/configured-ip-addresses YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses struct {
	ConfiguredIpAddress map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress `path:"configured-ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) IsYANGGoStruct() {}

// NewConfiguredIpAddress creates a new entry in the ConfiguredIpAddress list of the
// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) NewConfiguredIpAddress(Address string) (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConfiguredIpAddress == nil {
		t.ConfiguredIpAddress = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConfiguredIpAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConfiguredIpAddress", key)
	}

	t.ConfiguredIpAddress[key] = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress{
		Address: &Address,
	}

	return t.ConfiguredIpAddress[key], nil
}

// RenameConfiguredIpAddress renames an entry in the list ConfiguredIpAddress within
// the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) RenameConfiguredIpAddress(oldK, newK string) error {
	if _, ok := t.ConfiguredIpAddress[newK]; ok {
		return fmt.Errorf("key %v already exists in ConfiguredIpAddress", newK)
	}

	e, ok := t.ConfiguredIpAddress[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConfiguredIpAddress", oldK)
	}
	e.Address = &newK

	t.ConfiguredIpAddress[newK] = e
	delete(t.ConfiguredIpAddress, oldK)
	return nil
}

// GetOrCreateConfiguredIpAddressMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) GetOrCreateConfiguredIpAddressMap() map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress {
	if t.ConfiguredIpAddress == nil {
		t.ConfiguredIpAddress = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress)
	}
	return t.ConfiguredIpAddress
}

// GetOrCreateConfiguredIpAddress retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) GetOrCreateConfiguredIpAddress(Address string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress {

	key := Address

	if v, ok := t.ConfiguredIpAddress[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConfiguredIpAddress(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConfiguredIpAddress got unexpected error: %v", err))
	}
	return v
}

// GetConfiguredIpAddress retrieves the value with the specified key from
// the ConfiguredIpAddress map field of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) GetConfiguredIpAddress(Address string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.ConfiguredIpAddress[key]; ok {
		return lm
	}
	return nil
}

// AppendConfiguredIpAddress appends the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress struct to the
// list ConfiguredIpAddress of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) AppendConfiguredIpAddress(v *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key received for Address")
	}

	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConfiguredIpAddress == nil {
		t.ConfiguredIpAddress = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress)
	}

	if _, ok := t.ConfiguredIpAddress[key]; ok {
		return fmt.Errorf("duplicate key for list ConfiguredIpAddress %v", key)
	}

	t.ConfiguredIpAddress[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/configured-ip-addresses/configured-ip-address YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress struct {
	Address           *string                                  `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EncapsulationType E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEncap `path:"encapsulation-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryType         E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEntry `path:"entry-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddress   *string                                  `path:"hardware-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IpAddress         *string                                  `path:"ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/interface-configured-ip-addresses YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses struct {
	InterfaceConfiguredIpAddress []*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress `path:"interface-configured-ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/interface-configured-ip-addresses/interface-configured-ip-address YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress struct {
	Address                      *string                                                                                                                           `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	AssociatedConfigurationEntry *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry `path:"associated-configuration-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName                *string                                                                                                                           `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceNameXr              *string                                                                                                                           `path:"interface-name-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ReferenceCount               *uint32                                                                                                                           `path:"reference-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) IsYANGGoStruct() {
}

// GetOrCreateAssociatedConfigurationEntry retrieves the value of the AssociatedConfigurationEntry field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) GetOrCreateAssociatedConfigurationEntry() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry {
	if t.AssociatedConfigurationEntry != nil {
		return t.AssociatedConfigurationEntry
	}
	t.AssociatedConfigurationEntry = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry{}
	return t.AssociatedConfigurationEntry
}

// GetAssociatedConfigurationEntry returns the value of the AssociatedConfigurationEntry struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress. If the receiver or the field AssociatedConfigurationEntry is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) GetAssociatedConfigurationEntry() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry {
	if t != nil && t.AssociatedConfigurationEntry != nil {
		return t.AssociatedConfigurationEntry
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/interface-configured-ip-addresses/interface-configured-ip-address/associated-configuration-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry struct {
	EncapsulationType E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEncap `path:"encapsulation-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryType         E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEntry `path:"entry-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddress   *string                                  `path:"hardware-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IpAddress         *string                                  `path:"ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/routes YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes struct {
	Route []*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route `path:"route" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/routes/route YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route struct {
	Address         *string                                                               `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName   []*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceNameXr *string                                                               `path:"interface-name-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IpAddress       *string                                                               `path:"ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PrefixLength    *uint32                                                               `path:"prefix-length" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PrefixLengthXr  *uint8                                                                `path:"prefix-length-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/routes/route/interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes struct {
	Node map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node `path:"node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) IsYANGGoStruct() {}

// NewNode creates a new entry in the Node list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) NewNode(NodeName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node)
	}

	key := NodeName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Node[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Node", key)
	}

	t.Node[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node{
		NodeName: &NodeName,
	}

	return t.Node[key], nil
}

// RenameNode renames an entry in the list Node within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) RenameNode(oldK, newK string) error {
	if _, ok := t.Node[newK]; ok {
		return fmt.Errorf("key %v already exists in Node", newK)
	}

	e, ok := t.Node[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Node", oldK)
	}
	e.NodeName = &newK

	t.Node[newK] = e
	delete(t.Node, oldK)
	return nil
}

// GetOrCreateNodeMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) GetOrCreateNodeMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node {
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node)
	}
	return t.Node
}

// GetOrCreateNode retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) GetOrCreateNode(NodeName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node {

	key := NodeName

	if v, ok := t.Node[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNode(NodeName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNode got unexpected error: %v", err))
	}
	return v
}

// GetNode retrieves the value with the specified key from
// the Node map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) GetNode(NodeName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node {

	if t == nil {
		return nil
	}

	key := NodeName

	if lm, ok := t.Node[key]; ok {
		return lm
	}
	return nil
}

// AppendNode appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node struct to the
// list Node of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) AppendNode(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) error {
	if v.NodeName == nil {
		return fmt.Errorf("invalid nil key received for NodeName")
	}

	key := *v.NodeName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node)
	}

	if _, ok := t.Node[key]; ok {
		return fmt.Errorf("duplicate key for list Node %v", key)
	}

	t.Node[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node struct {
	AdjacencyHistoryAll                                  *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll                                  `path:"adjacency-history-all" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	AdjacencyHistoryInterfaceNames                       *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames                       `path:"adjacency-history-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpHostTrackingSessions                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions                              `path:"arp-host-tracking-sessions" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpRedSyncGids                                       *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids                                       `path:"arp-red-sync-gids" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpStats                                             *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats                                             `path:"arp-stats" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpStatusInfo                                        *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo                                        `path:"arp-status-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientIds                                            *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds                                            `path:"client-ids" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DirectAttachedGatewayRedundancyInterfaceAndAddresses *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses `path:"direct-attached-gateway-redundancy-interface-and-addresses" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Entries                                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries                                              `path:"entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbEventsInterfaceNames                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames                              `path:"idb-events-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceNames                                    *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames                                    `path:"idb-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NodeName                                             *string                                                                                      `path:"node-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PacketHistoryAll                                     *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll                                     `path:"packet-history-all" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PacketHistoryInterfaceNames                          *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames                          `path:"packet-history-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionHistoryClient                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient                              `path:"resolution-history-client" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionHistoryDynamic                             *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic                             `path:"resolution-history-dynamic" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadQueueStatistics                                *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics                                `path:"thread-queue-statistics" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TrafficInterfaces                                    *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces                                    `path:"traffic-interfaces" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TrafficNode                                          *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode                                          `path:"traffic-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TrafficVrfs                                          *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs                                          `path:"traffic-vrfs" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) IsYANGGoStruct() {}

// GetOrCreateAdjacencyHistoryAll retrieves the value of the AdjacencyHistoryAll field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateAdjacencyHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll {
	if t.AdjacencyHistoryAll != nil {
		return t.AdjacencyHistoryAll
	}
	t.AdjacencyHistoryAll = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll{}
	return t.AdjacencyHistoryAll
}

// GetOrCreateAdjacencyHistoryInterfaceNames retrieves the value of the AdjacencyHistoryInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateAdjacencyHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames {
	if t.AdjacencyHistoryInterfaceNames != nil {
		return t.AdjacencyHistoryInterfaceNames
	}
	t.AdjacencyHistoryInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames{}
	return t.AdjacencyHistoryInterfaceNames
}

// GetOrCreateArpHostTrackingSessions retrieves the value of the ArpHostTrackingSessions field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpHostTrackingSessions() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions {
	if t.ArpHostTrackingSessions != nil {
		return t.ArpHostTrackingSessions
	}
	t.ArpHostTrackingSessions = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions{}
	return t.ArpHostTrackingSessions
}

// GetOrCreateArpRedSyncGids retrieves the value of the ArpRedSyncGids field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpRedSyncGids() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids {
	if t.ArpRedSyncGids != nil {
		return t.ArpRedSyncGids
	}
	t.ArpRedSyncGids = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids{}
	return t.ArpRedSyncGids
}

// GetOrCreateArpStats retrieves the value of the ArpStats field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpStats() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats {
	if t.ArpStats != nil {
		return t.ArpStats
	}
	t.ArpStats = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats{}
	return t.ArpStats
}

// GetOrCreateArpStatusInfo retrieves the value of the ArpStatusInfo field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpStatusInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo {
	if t.ArpStatusInfo != nil {
		return t.ArpStatusInfo
	}
	t.ArpStatusInfo = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo{}
	return t.ArpStatusInfo
}

// GetOrCreateClientIds retrieves the value of the ClientIds field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateClientIds() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds {
	if t.ClientIds != nil {
		return t.ClientIds
	}
	t.ClientIds = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds{}
	return t.ClientIds
}

// GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddresses retrieves the value of the DirectAttachedGatewayRedundancyInterfaceAndAddresses field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddresses() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses {
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddresses != nil {
		return t.DirectAttachedGatewayRedundancyInterfaceAndAddresses
	}
	t.DirectAttachedGatewayRedundancyInterfaceAndAddresses = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses{}
	return t.DirectAttachedGatewayRedundancyInterfaceAndAddresses
}

// GetOrCreateEntries retrieves the value of the Entries field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateEntries() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries {
	if t.Entries != nil {
		return t.Entries
	}
	t.Entries = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries{}
	return t.Entries
}

// GetOrCreateIdbEventsInterfaceNames retrieves the value of the IdbEventsInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateIdbEventsInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames {
	if t.IdbEventsInterfaceNames != nil {
		return t.IdbEventsInterfaceNames
	}
	t.IdbEventsInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames{}
	return t.IdbEventsInterfaceNames
}

// GetOrCreateIdbInterfaceNames retrieves the value of the IdbInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateIdbInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames {
	if t.IdbInterfaceNames != nil {
		return t.IdbInterfaceNames
	}
	t.IdbInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames{}
	return t.IdbInterfaceNames
}

// GetOrCreatePacketHistoryAll retrieves the value of the PacketHistoryAll field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreatePacketHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll {
	if t.PacketHistoryAll != nil {
		return t.PacketHistoryAll
	}
	t.PacketHistoryAll = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll{}
	return t.PacketHistoryAll
}

// GetOrCreatePacketHistoryInterfaceNames retrieves the value of the PacketHistoryInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreatePacketHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames {
	if t.PacketHistoryInterfaceNames != nil {
		return t.PacketHistoryInterfaceNames
	}
	t.PacketHistoryInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames{}
	return t.PacketHistoryInterfaceNames
}

// GetOrCreateResolutionHistoryClient retrieves the value of the ResolutionHistoryClient field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateResolutionHistoryClient() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient {
	if t.ResolutionHistoryClient != nil {
		return t.ResolutionHistoryClient
	}
	t.ResolutionHistoryClient = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient{}
	return t.ResolutionHistoryClient
}

// GetOrCreateResolutionHistoryDynamic retrieves the value of the ResolutionHistoryDynamic field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateResolutionHistoryDynamic() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic {
	if t.ResolutionHistoryDynamic != nil {
		return t.ResolutionHistoryDynamic
	}
	t.ResolutionHistoryDynamic = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic{}
	return t.ResolutionHistoryDynamic
}

// GetOrCreateThreadQueueStatistics retrieves the value of the ThreadQueueStatistics field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateThreadQueueStatistics() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics {
	if t.ThreadQueueStatistics != nil {
		return t.ThreadQueueStatistics
	}
	t.ThreadQueueStatistics = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics{}
	return t.ThreadQueueStatistics
}

// GetOrCreateTrafficInterfaces retrieves the value of the TrafficInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateTrafficInterfaces() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces {
	if t.TrafficInterfaces != nil {
		return t.TrafficInterfaces
	}
	t.TrafficInterfaces = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces{}
	return t.TrafficInterfaces
}

// GetOrCreateTrafficNode retrieves the value of the TrafficNode field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateTrafficNode() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode {
	if t.TrafficNode != nil {
		return t.TrafficNode
	}
	t.TrafficNode = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode{}
	return t.TrafficNode
}

// GetOrCreateTrafficVrfs retrieves the value of the TrafficVrfs field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateTrafficVrfs() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs {
	if t.TrafficVrfs != nil {
		return t.TrafficVrfs
	}
	t.TrafficVrfs = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs{}
	return t.TrafficVrfs
}

// GetAdjacencyHistoryAll returns the value of the AdjacencyHistoryAll struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field AdjacencyHistoryAll is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetAdjacencyHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll {
	if t != nil && t.AdjacencyHistoryAll != nil {
		return t.AdjacencyHistoryAll
	}
	return nil
}

// GetAdjacencyHistoryInterfaceNames returns the value of the AdjacencyHistoryInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field AdjacencyHistoryInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetAdjacencyHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames {
	if t != nil && t.AdjacencyHistoryInterfaceNames != nil {
		return t.AdjacencyHistoryInterfaceNames
	}
	return nil
}

// GetArpHostTrackingSessions returns the value of the ArpHostTrackingSessions struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpHostTrackingSessions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpHostTrackingSessions() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions {
	if t != nil && t.ArpHostTrackingSessions != nil {
		return t.ArpHostTrackingSessions
	}
	return nil
}

// GetArpRedSyncGids returns the value of the ArpRedSyncGids struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpRedSyncGids is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpRedSyncGids() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids {
	if t != nil && t.ArpRedSyncGids != nil {
		return t.ArpRedSyncGids
	}
	return nil
}

// GetArpStats returns the value of the ArpStats struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpStats is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpStats() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats {
	if t != nil && t.ArpStats != nil {
		return t.ArpStats
	}
	return nil
}

// GetArpStatusInfo returns the value of the ArpStatusInfo struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpStatusInfo is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpStatusInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo {
	if t != nil && t.ArpStatusInfo != nil {
		return t.ArpStatusInfo
	}
	return nil
}

// GetClientIds returns the value of the ClientIds struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ClientIds is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetClientIds() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds {
	if t != nil && t.ClientIds != nil {
		return t.ClientIds
	}
	return nil
}

// GetDirectAttachedGatewayRedundancyInterfaceAndAddresses returns the value of the DirectAttachedGatewayRedundancyInterfaceAndAddresses struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field DirectAttachedGatewayRedundancyInterfaceAndAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetDirectAttachedGatewayRedundancyInterfaceAndAddresses() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses {
	if t != nil && t.DirectAttachedGatewayRedundancyInterfaceAndAddresses != nil {
		return t.DirectAttachedGatewayRedundancyInterfaceAndAddresses
	}
	return nil
}

// GetEntries returns the value of the Entries struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field Entries is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetEntries() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries {
	if t != nil && t.Entries != nil {
		return t.Entries
	}
	return nil
}

// GetIdbEventsInterfaceNames returns the value of the IdbEventsInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field IdbEventsInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetIdbEventsInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames {
	if t != nil && t.IdbEventsInterfaceNames != nil {
		return t.IdbEventsInterfaceNames
	}
	return nil
}

// GetIdbInterfaceNames returns the value of the IdbInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field IdbInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetIdbInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames {
	if t != nil && t.IdbInterfaceNames != nil {
		return t.IdbInterfaceNames
	}
	return nil
}

// GetPacketHistoryAll returns the value of the PacketHistoryAll struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field PacketHistoryAll is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetPacketHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll {
	if t != nil && t.PacketHistoryAll != nil {
		return t.PacketHistoryAll
	}
	return nil
}

// GetPacketHistoryInterfaceNames returns the value of the PacketHistoryInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field PacketHistoryInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetPacketHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames {
	if t != nil && t.PacketHistoryInterfaceNames != nil {
		return t.PacketHistoryInterfaceNames
	}
	return nil
}

// GetResolutionHistoryClient returns the value of the ResolutionHistoryClient struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ResolutionHistoryClient is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetResolutionHistoryClient() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient {
	if t != nil && t.ResolutionHistoryClient != nil {
		return t.ResolutionHistoryClient
	}
	return nil
}

// GetResolutionHistoryDynamic returns the value of the ResolutionHistoryDynamic struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ResolutionHistoryDynamic is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetResolutionHistoryDynamic() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic {
	if t != nil && t.ResolutionHistoryDynamic != nil {
		return t.ResolutionHistoryDynamic
	}
	return nil
}

// GetThreadQueueStatistics returns the value of the ThreadQueueStatistics struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ThreadQueueStatistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetThreadQueueStatistics() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics {
	if t != nil && t.ThreadQueueStatistics != nil {
		return t.ThreadQueueStatistics
	}
	return nil
}

// GetTrafficInterfaces returns the value of the TrafficInterfaces struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field TrafficInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetTrafficInterfaces() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces {
	if t != nil && t.TrafficInterfaces != nil {
		return t.TrafficInterfaces
	}
	return nil
}

// GetTrafficNode returns the value of the TrafficNode struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field TrafficNode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetTrafficNode() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode {
	if t != nil && t.TrafficNode != nil {
		return t.TrafficNode
	}
	return nil
}

// GetTrafficVrfs returns the value of the TrafficVrfs struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field TrafficVrfs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetTrafficVrfs() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs {
	if t != nil && t.TrafficVrfs != nil {
		return t.TrafficVrfs
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeName == nil {
		return nil, fmt.Errorf("nil value for key NodeName")
	}

	return map[string]interface{}{
		"node-name": *t.NodeName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-all YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-all/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry struct {
	ClientId         *int32  `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState       *int32  `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address      *string `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress       *string `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Protocol         *int32  `path:"protocol" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Result           *int32  `path:"result" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames struct {
	AdjacencyHistoryInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName `path:"adjacency-history-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) IsYANGGoStruct() {}

// NewAdjacencyHistoryInterfaceName creates a new entry in the AdjacencyHistoryInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) NewAdjacencyHistoryInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencyHistoryInterfaceName == nil {
		t.AdjacencyHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencyHistoryInterfaceName", key)
	}

	t.AdjacencyHistoryInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.AdjacencyHistoryInterfaceName[key], nil
}

// RenameAdjacencyHistoryInterfaceName renames an entry in the list AdjacencyHistoryInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) RenameAdjacencyHistoryInterfaceName(oldK, newK string) error {
	if _, ok := t.AdjacencyHistoryInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencyHistoryInterfaceName", newK)
	}

	e, ok := t.AdjacencyHistoryInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencyHistoryInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.AdjacencyHistoryInterfaceName[newK] = e
	delete(t.AdjacencyHistoryInterfaceName, oldK)
	return nil
}

// GetOrCreateAdjacencyHistoryInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) GetOrCreateAdjacencyHistoryInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName {
	if t.AdjacencyHistoryInterfaceName == nil {
		t.AdjacencyHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName)
	}
	return t.AdjacencyHistoryInterfaceName
}

// GetOrCreateAdjacencyHistoryInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) GetOrCreateAdjacencyHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName {

	key := InterfaceName

	if v, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencyHistoryInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencyHistoryInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencyHistoryInterfaceName retrieves the value with the specified key from
// the AdjacencyHistoryInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) GetAdjacencyHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacencyHistoryInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName struct to the
// list AdjacencyHistoryInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) AppendAdjacencyHistoryInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencyHistoryInterfaceName == nil {
		t.AdjacencyHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName)
	}

	if _, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencyHistoryInterfaceName %v", key)
	}

	t.AdjacencyHistoryInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-interface-names/adjacency-history-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName struct {
	ArpEntry      []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string                                                                                                         `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-interface-names/adjacency-history-interface-name/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry struct {
	ClientId         *int32  `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState       *int32  `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address      *string `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress       *string `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Protocol         *int32  `path:"protocol" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Result           *int32  `path:"result" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-host-tracking-sessions YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions struct {
	ArpHostTrackingSession map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession `path:"arp-host-tracking-session" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) IsYANGGoStruct() {}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key represents the key for list ArpHostTrackingSession of element /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-host-tracking-sessions.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key struct {
	InterfaceName string `path:"interface-name"`
	Address       string `path:"address"`
}

// IsYANGGoKeyStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key) IsYANGGoKeyStruct() {
}

// ΛListKeyMap returns the values of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key key struct.
func (t Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"interface-name": t.InterfaceName,
		"address":        t.Address,
	}, nil
}

// NewArpHostTrackingSession creates a new entry in the ArpHostTrackingSession list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) NewArpHostTrackingSession(InterfaceName string, Address string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpHostTrackingSession == nil {
		t.ArpHostTrackingSession = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession)
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ArpHostTrackingSession[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ArpHostTrackingSession", key)
	}

	t.ArpHostTrackingSession[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession{
		InterfaceName: &InterfaceName,
		Address:       &Address,
	}

	return t.ArpHostTrackingSession[key], nil
}

// RenameArpHostTrackingSession renames an entry in the list ArpHostTrackingSession within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) RenameArpHostTrackingSession(oldK, newK Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key) error {
	if _, ok := t.ArpHostTrackingSession[newK]; ok {
		return fmt.Errorf("key %v already exists in ArpHostTrackingSession", newK)
	}

	e, ok := t.ArpHostTrackingSession[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ArpHostTrackingSession", oldK)
	}
	e.InterfaceName = &newK.InterfaceName
	e.Address = &newK.Address

	t.ArpHostTrackingSession[newK] = e
	delete(t.ArpHostTrackingSession, oldK)
	return nil
}

// GetOrCreateArpHostTrackingSessionMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) GetOrCreateArpHostTrackingSessionMap() map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession {
	if t.ArpHostTrackingSession == nil {
		t.ArpHostTrackingSession = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession)
	}
	return t.ArpHostTrackingSession
}

// GetOrCreateArpHostTrackingSession retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) GetOrCreateArpHostTrackingSession(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession {

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if v, ok := t.ArpHostTrackingSession[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewArpHostTrackingSession(InterfaceName, Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateArpHostTrackingSession got unexpected error: %v", err))
	}
	return v
}

// GetArpHostTrackingSession retrieves the value with the specified key from
// the ArpHostTrackingSession map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) GetArpHostTrackingSession(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession {

	if t == nil {
		return nil
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if lm, ok := t.ArpHostTrackingSession[key]; ok {
		return lm
	}
	return nil
}

// AppendArpHostTrackingSession appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession struct to the
// list ArpHostTrackingSession of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) AppendArpHostTrackingSession(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key for InterfaceName")
	}

	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: *v.InterfaceName,
		Address:       *v.Address,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpHostTrackingSession == nil {
		t.ArpHostTrackingSession = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession)
	}

	if _, ok := t.ArpHostTrackingSession[key]; ok {
		return fmt.Errorf("duplicate key for list ArpHostTrackingSession %v", key)
	}

	t.ArpHostTrackingSession[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-host-tracking-sessions/arp-host-tracking-session YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession struct {
	Address          *string                                       `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DestAddress      *string                                       `path:"dest-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string                                       `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName    *string                                       `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	State            E_Cisco_IOS_XRIpv4ArpOper_IpArpHostTrackState `path:"state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"address":        *t.Address,
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-red-sync-gids YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids struct {
	ArpRedSyncGid map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid `path:"arp-red-sync-gid" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) IsYANGGoStruct() {}

// NewArpRedSyncGid creates a new entry in the ArpRedSyncGid list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) NewArpRedSyncGid(GroupId uint32) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpRedSyncGid == nil {
		t.ArpRedSyncGid = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid)
	}

	key := GroupId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ArpRedSyncGid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ArpRedSyncGid", key)
	}

	t.ArpRedSyncGid[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid{
		GroupId: &GroupId,
	}

	return t.ArpRedSyncGid[key], nil
}

// RenameArpRedSyncGid renames an entry in the list ArpRedSyncGid within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) RenameArpRedSyncGid(oldK, newK uint32) error {
	if _, ok := t.ArpRedSyncGid[newK]; ok {
		return fmt.Errorf("key %v already exists in ArpRedSyncGid", newK)
	}

	e, ok := t.ArpRedSyncGid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ArpRedSyncGid", oldK)
	}
	e.GroupId = &newK

	t.ArpRedSyncGid[newK] = e
	delete(t.ArpRedSyncGid, oldK)
	return nil
}

// GetOrCreateArpRedSyncGidMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) GetOrCreateArpRedSyncGidMap() map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid {
	if t.ArpRedSyncGid == nil {
		t.ArpRedSyncGid = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid)
	}
	return t.ArpRedSyncGid
}

// GetOrCreateArpRedSyncGid retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) GetOrCreateArpRedSyncGid(GroupId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid {

	key := GroupId

	if v, ok := t.ArpRedSyncGid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewArpRedSyncGid(GroupId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateArpRedSyncGid got unexpected error: %v", err))
	}
	return v
}

// GetArpRedSyncGid retrieves the value with the specified key from
// the ArpRedSyncGid map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) GetArpRedSyncGid(GroupId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid {

	if t == nil {
		return nil
	}

	key := GroupId

	if lm, ok := t.ArpRedSyncGid[key]; ok {
		return lm
	}
	return nil
}

// AppendArpRedSyncGid appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid struct to the
// list ArpRedSyncGid of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) AppendArpRedSyncGid(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) error {
	if v.GroupId == nil {
		return fmt.Errorf("invalid nil key received for GroupId")
	}

	key := *v.GroupId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpRedSyncGid == nil {
		t.ArpRedSyncGid = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid)
	}

	if _, ok := t.ArpRedSyncGid[key]; ok {
		return fmt.Errorf("duplicate key for list ArpRedSyncGid %v", key)
	}

	t.ArpRedSyncGid[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-red-sync-gids/arp-red-sync-gid YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid struct {
	GroupId    *uint32                                    `path:"group-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GroupIdXr  *uint16                                    `path:"group-id-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeerAdd    *string                                    `path:"peer-add" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeerStatus E_Cisco_IOS_XRIpv4ArpOper_ArpPeerStatusBag `path:"peer-status" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrcIntName *string                                    `path:"src-int-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GroupId == nil {
		return nil, fmt.Errorf("nil value for key GroupId")
	}

	return map[string]interface{}{
		"group-id": *t.GroupId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-stats YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-status-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo struct {
	AllIdbClientResyncTime                 *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime `path:"all-idb-client-resync-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BigBangTime                            *uint64                                                                      `path:"big-bang-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntriesRecoveredCount           *uint32                                                                      `path:"dynamic-entries-recovered-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceHandleTranslationFailureCount *uint32                                                                      `path:"interface-handle-translation-failure-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyDagrRib                       *bool                                                                        `path:"issu-ready-dagr-rib" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyEntriesReplicate              *bool                                                                        `path:"issu-ready-entries-replicate" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyIm                            *bool                                                                        `path:"issu-ready-im" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyIssuMgrConnection             *bool                                                                        `path:"issu-ready-issu-mgr-connection" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyTime                          *uint64                                                                      `path:"issu-ready-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuSyncCompleteTime                   *uint64                                                                      `path:"issu-sync-complete-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NonOperationalEntriesCount             *uint32                                                                      `path:"non-operational-entries-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Phase                                  E_Cisco_IOS_XRIpv4ArpOper_ArpIssuPhase                                       `path:"phase" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PrimaryRoleTime                        *uint64                                                                      `path:"primary-role-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProcessStartTime                       *uint64                                                                      `path:"process-start-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Role                                   E_Cisco_IOS_XRIpv4ArpOper_ArpIssuRole                                        `path:"role" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Version                                E_Cisco_IOS_XRIpv4ArpOper_ArpIssuVersion                                     `path:"version" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) IsYANGGoStruct() {}

// GetOrCreateAllIdbClientResyncTime retrieves the value of the AllIdbClientResyncTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) GetOrCreateAllIdbClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime {
	if t.AllIdbClientResyncTime != nil {
		return t.AllIdbClientResyncTime
	}
	t.AllIdbClientResyncTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime{}
	return t.AllIdbClientResyncTime
}

// GetAllIdbClientResyncTime returns the value of the AllIdbClientResyncTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo. If the receiver or the field AllIdbClientResyncTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) GetAllIdbClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime {
	if t != nil && t.AllIdbClientResyncTime != nil {
		return t.AllIdbClientResyncTime
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-status-info/all-idb-client-resync-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/client-ids YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds struct {
	ClientId map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) IsYANGGoStruct() {}

// NewClientId creates a new entry in the ClientId list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) NewClientId(ClientId uint32) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientId == nil {
		t.ClientId = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId)
	}

	key := ClientId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ClientId[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ClientId", key)
	}

	t.ClientId[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId{
		ClientId: &ClientId,
	}

	return t.ClientId[key], nil
}

// RenameClientId renames an entry in the list ClientId within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) RenameClientId(oldK, newK uint32) error {
	if _, ok := t.ClientId[newK]; ok {
		return fmt.Errorf("key %v already exists in ClientId", newK)
	}

	e, ok := t.ClientId[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ClientId", oldK)
	}
	e.ClientId = &newK

	t.ClientId[newK] = e
	delete(t.ClientId, oldK)
	return nil
}

// GetOrCreateClientIdMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) GetOrCreateClientIdMap() map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId {
	if t.ClientId == nil {
		t.ClientId = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId)
	}
	return t.ClientId
}

// GetOrCreateClientId retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) GetOrCreateClientId(ClientId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId {

	key := ClientId

	if v, ok := t.ClientId[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewClientId(ClientId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateClientId got unexpected error: %v", err))
	}
	return v
}

// GetClientId retrieves the value with the specified key from
// the ClientId map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) GetClientId(ClientId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId {

	if t == nil {
		return nil
	}

	key := ClientId

	if lm, ok := t.ClientId[key]; ok {
		return lm
	}
	return nil
}

// AppendClientId appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId struct to the
// list ClientId of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) AppendClientId(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) error {
	if v.ClientId == nil {
		return fmt.Errorf("invalid nil key received for ClientId")
	}

	key := *v.ClientId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientId == nil {
		t.ClientId = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId)
	}

	if _, ok := t.ClientId[key]; ok {
		return fmt.Errorf("duplicate key for list ClientId %v", key)
	}

	t.ClientId[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/client-ids/client-id YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId struct {
	ClientId       *uint32 `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientIdXr     *uint32 `path:"client-id-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntriesAdded   *uint32 `path:"entries-added" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntriesDeleted *uint32 `path:"entries-deleted" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RegTime        *uint64 `path:"reg-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SendRequest    *uint32 `path:"send-request" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	UnregTime      *uint64 `path:"unreg-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ClientId == nil {
		return nil, fmt.Errorf("nil value for key ClientId")
	}

	return map[string]interface{}{
		"client-id": *t.ClientId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/direct-attached-gateway-redundancy-interface-and-addresses YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses struct {
	DirectAttachedGatewayRedundancyInterfaceAndAddress map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress `path:"direct-attached-gateway-redundancy-interface-and-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) IsYANGGoStruct() {
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key represents the key for list DirectAttachedGatewayRedundancyInterfaceAndAddress of element /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/direct-attached-gateway-redundancy-interface-and-addresses.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key struct {
	InterfaceName string `path:"interface-name"`
	Address       string `path:"address"`
}

// IsYANGGoKeyStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key) IsYANGGoKeyStruct() {
}

// ΛListKeyMap returns the values of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key key struct.
func (t Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"interface-name": t.InterfaceName,
		"address":        t.Address,
	}, nil
}

// NewDirectAttachedGatewayRedundancyInterfaceAndAddress creates a new entry in the DirectAttachedGatewayRedundancyInterfaceAndAddress list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) NewDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName string, Address string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddress == nil {
		t.DirectAttachedGatewayRedundancyInterfaceAndAddress = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress)
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DirectAttachedGatewayRedundancyInterfaceAndAddress", key)
	}

	t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress{
		InterfaceName: &InterfaceName,
		Address:       &Address,
	}

	return t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key], nil
}

// RenameDirectAttachedGatewayRedundancyInterfaceAndAddress renames an entry in the list DirectAttachedGatewayRedundancyInterfaceAndAddress within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) RenameDirectAttachedGatewayRedundancyInterfaceAndAddress(oldK, newK Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key) error {
	if _, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[newK]; ok {
		return fmt.Errorf("key %v already exists in DirectAttachedGatewayRedundancyInterfaceAndAddress", newK)
	}

	e, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DirectAttachedGatewayRedundancyInterfaceAndAddress", oldK)
	}
	e.InterfaceName = &newK.InterfaceName
	e.Address = &newK.Address

	t.DirectAttachedGatewayRedundancyInterfaceAndAddress[newK] = e
	delete(t.DirectAttachedGatewayRedundancyInterfaceAndAddress, oldK)
	return nil
}

// GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddressMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddressMap() map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress {
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddress == nil {
		t.DirectAttachedGatewayRedundancyInterfaceAndAddress = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress)
	}
	return t.DirectAttachedGatewayRedundancyInterfaceAndAddress
}

// GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddress retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress {

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if v, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName, Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddress got unexpected error: %v", err))
	}
	return v
}

// GetDirectAttachedGatewayRedundancyInterfaceAndAddress retrieves the value with the specified key from
// the DirectAttachedGatewayRedundancyInterfaceAndAddress map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) GetDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress {

	if t == nil {
		return nil
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if lm, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return lm
	}
	return nil
}

// AppendDirectAttachedGatewayRedundancyInterfaceAndAddress appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress struct to the
// list DirectAttachedGatewayRedundancyInterfaceAndAddress of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) AppendDirectAttachedGatewayRedundancyInterfaceAndAddress(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key for InterfaceName")
	}

	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: *v.InterfaceName,
		Address:       *v.Address,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddress == nil {
		t.DirectAttachedGatewayRedundancyInterfaceAndAddress = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress)
	}

	if _, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return fmt.Errorf("duplicate key for list DirectAttachedGatewayRedundancyInterfaceAndAddress %v", key)
	}

	t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/direct-attached-gateway-redundancy-interface-and-addresses/direct-attached-gateway-redundancy-interface-and-address YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress struct {
	Address       *string `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Dist          *uint32 `path:"dist" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ifhandle      *string `path:"ifhandle" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Metric        *uint32 `path:"metric" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QueryPeriod   *uint32 `path:"query-period" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	State         *string `path:"state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Vip           *string `path:"vip" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"address":        *t.Address,
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/entries YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries struct {
	Entry map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry `path:"entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) IsYANGGoStruct() {}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key represents the key for list Entry of element /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/entries.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key struct {
	Address       string `path:"address"`
	InterfaceName string `path:"interface-name"`
}

// IsYANGGoKeyStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key key struct.
func (t Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"address":        t.Address,
		"interface-name": t.InterfaceName,
	}, nil
}

// NewEntry creates a new entry in the Entry list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) NewEntry(Address string, InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry)
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       Address,
		InterfaceName: InterfaceName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry{
		Address:       &Address,
		InterfaceName: &InterfaceName,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) RenameEntry(oldK, newK Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Address = &newK.Address
	e.InterfaceName = &newK.InterfaceName

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntryMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) GetOrCreateEntryMap() map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry {
	if t.Entry == nil {
		t.Entry = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry)
	}
	return t.Entry
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) GetOrCreateEntry(Address string, InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry {

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       Address,
		InterfaceName: InterfaceName,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Address, InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) GetEntry(Address string, InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry {

	if t == nil {
		return nil
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       Address,
		InterfaceName: InterfaceName,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// AppendEntry appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry struct to the
// list Entry of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) AppendEntry(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key for InterfaceName")
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       *v.Address,
		InterfaceName: *v.InterfaceName,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}
