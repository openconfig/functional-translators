/*
Package native is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /usr/local/google/home/orem/go/pkg/mod/github.com/openconfig/ygot@v0.33.0/genutil/names.go
using the following YANG input files:
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ifmgr-cfg.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-infra-statsd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-infra-statsd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ip-iarm-datatypes.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub3.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-types.yang
  - yang/vendor/cisco/xr/2431/cisco-semver.yang
  - yang/vendor/cisco/xr/2431/ietf-inet-types.yang

Imported modules were sourced from:
  - yang/vendor/cisco/xr/2431/...
*/
package native

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/helper-address YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress struct {
	AddressArray []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray `path:"address-array" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/helper-address/address-array YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress_AddressArray) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/multi-acl YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl struct {
	Common   []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common   `path:"common" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Inbound  []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound  `path:"inbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Outbound []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound `path:"outbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/multi-acl/common YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Common) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/multi-acl/inbound YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Inbound) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/multi-acl/outbound YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl_Outbound) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/multicast-group YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup struct {
	GroupAddress *string `path:"group-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/rpf YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf struct {
	AllowDefaultRoute *bool                            `path:"allow-default-route" module:"Cisco-IOS-XR-ipv4-io-oper"`
	AllowSelfPing     *bool                            `path:"allow-self-ping" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Enable            *bool                            `path:"enable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Mode              E_Cisco_IOS_XRIpv4IoOper_RpfMode `path:"mode" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/secondary-address YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress struct {
	Address      *string `path:"address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Algorithm    *uint32 `path:"algorithm" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PrefixLength *uint32 `path:"prefix-length" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RouteTag     *uint32 `path:"route-tag" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/statistics YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics struct {
	Traffic *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic `path:"traffic" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics) IsYANGGoStruct() {}

// GetOrCreateTraffic retrieves the value of the Traffic field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics) GetOrCreateTraffic() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic {
	if t.Traffic != nil {
		return t.Traffic
	}
	t.Traffic = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic{}
	return t.Traffic
}

// GetTraffic returns the value of the Traffic struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics. If the receiver or the field Traffic is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics) GetTraffic() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic {
	if t != nil && t.Traffic != nil {
		return t.Traffic
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/statistics/traffic YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic struct {
	IcmpStats *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats `path:"icmp-stats" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Ipv4Stats *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats `path:"ipv4-stats" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) IsYANGGoStruct() {}

// GetOrCreateIcmpStats retrieves the value of the IcmpStats field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) GetOrCreateIcmpStats() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats {
	if t.IcmpStats != nil {
		return t.IcmpStats
	}
	t.IcmpStats = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats{}
	return t.IcmpStats
}

// GetOrCreateIpv4Stats retrieves the value of the Ipv4Stats field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) GetOrCreateIpv4Stats() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats {
	if t.Ipv4Stats != nil {
		return t.Ipv4Stats
	}
	t.Ipv4Stats = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats{}
	return t.Ipv4Stats
}

// GetIcmpStats returns the value of the IcmpStats struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic. If the receiver or the field IcmpStats is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) GetIcmpStats() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats {
	if t != nil && t.IcmpStats != nil {
		return t.IcmpStats
	}
	return nil
}

// GetIpv4Stats returns the value of the Ipv4Stats struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic. If the receiver or the field Ipv4Stats is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) GetIpv4Stats() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats {
	if t != nil && t.Ipv4Stats != nil {
		return t.Ipv4Stats
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/statistics/traffic/icmp-stats YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats struct {
	AdminUnreachableReceived    *uint32 `path:"admin-unreachable-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	AdminUnreachableSent        *uint32 `path:"admin-unreachable-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ChecksumError               *uint32 `path:"checksum-error" module:"Cisco-IOS-XR-ipv4-io-oper"`
	EchoReplyReceived           *uint32 `path:"echo-reply-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	EchoReplySent               *uint32 `path:"echo-reply-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	EchoRequestReceived         *uint32 `path:"echo-request-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	EchoRequestSent             *uint32 `path:"echo-request-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FragmentUnreachableReceived *uint32 `path:"fragment-unreachable-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FragmentUnreachableSent     *uint32 `path:"fragment-unreachable-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	HopcountReceived            *uint32 `path:"hopcount-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	HopcountSent                *uint32 `path:"hopcount-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	HostUnreachableReceived     *uint32 `path:"host-unreachable-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	HostUnreachableSent         *uint32 `path:"host-unreachable-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MaskReplyReceived           *uint32 `path:"mask-reply-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MaskReplySent               *uint32 `path:"mask-reply-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MaskRequestReceived         *uint32 `path:"mask-request-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MaskRequestSent             *uint32 `path:"mask-request-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NetworkUnreachableReceived  *uint32 `path:"network-unreachable-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NetworkUnreachableSent      *uint32 `path:"network-unreachable-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Output                      *uint32 `path:"output" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ParamErrorReceived          *uint32 `path:"param-error-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ParamErrorSend              *uint32 `path:"param-error-send" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PortUnreachableReceived     *uint32 `path:"port-unreachable-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PortUnreachableSent         *uint32 `path:"port-unreachable-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProtocolUnreachableReceived *uint32 `path:"protocol-unreachable-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProtocolUnreachableSent     *uint32 `path:"protocol-unreachable-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ReasseblyReceived           *uint32 `path:"reassebly-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ReassemblySent              *uint32 `path:"reassembly-sent" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Received                    *uint32 `path:"received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RedirectReceived            *uint32 `path:"redirect-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RedirectSend                *uint32 `path:"redirect-send" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RouterAdvertReceived        *uint32 `path:"router-advert-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RouterSolicitReceived       *uint32 `path:"router-solicit-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	SourceQuenchReceived        *uint32 `path:"source-quench-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	TimestampReceived           *uint32 `path:"timestamp-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	TimestampReplyReceived      *uint32 `path:"timestamp-reply-received" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Unknown                     *uint32 `path:"unknown" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_IcmpStats) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/statistics/traffic/ipv4-stats YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats struct {
	BadHeader               *uint32 `path:"bad-header" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BadHopCount             *uint32 `path:"bad-hop-count" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BadOption               *uint32 `path:"bad-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BadSecurityOption       *uint32 `path:"bad-security-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BadSourceAddress        *uint32 `path:"bad-source-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BasicSecurityOption     *uint32 `path:"basic-security-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BroadcastIn             *uint32 `path:"broadcast-in" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BroadcastOut            *uint32 `path:"broadcast-out" module:"Cisco-IOS-XR-ipv4-io-oper"`
	CipsoOption             *uint32 `path:"cipso-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	EncapsulationFailed     *uint32 `path:"encapsulation-failed" module:"Cisco-IOS-XR-ipv4-io-oper"`
	EndOption               *uint32 `path:"end-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ExtendedSecurityOption  *uint32 `path:"extended-security-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FormatErrors            *uint32 `path:"format-errors" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FragmentCount           *uint32 `path:"fragment-count" module:"Cisco-IOS-XR-ipv4-io-oper"`
	InputPackets            *uint32 `path:"input-packets" module:"Cisco-IOS-XR-ipv4-io-oper"`
	LispDecapError          *uint32 `path:"lisp-decap-error" module:"Cisco-IOS-XR-ipv4-io-oper"`
	LispEncapError          *uint32 `path:"lisp-encap-error" module:"Cisco-IOS-XR-ipv4-io-oper"`
	LispV4Decap             *uint32 `path:"lisp-v4-decap" module:"Cisco-IOS-XR-ipv4-io-oper"`
	LispV4Encap             *uint32 `path:"lisp-v4-encap" module:"Cisco-IOS-XR-ipv4-io-oper"`
	LispV6Decap             *uint32 `path:"lisp-v6-decap" module:"Cisco-IOS-XR-ipv4-io-oper"`
	LispV6Encap             *uint32 `path:"lisp-v6-encap" module:"Cisco-IOS-XR-ipv4-io-oper"`
	LooseSourceRouteOption  *uint32 `path:"loose-source-route-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MulticastIn             *uint32 `path:"multicast-in" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MulticastOut            *uint32 `path:"multicast-out" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NoGateway               *uint32 `path:"no-gateway" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NoProtocol              *uint32 `path:"no-protocol" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NoRouter                *uint32 `path:"no-router" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NoopOption              *uint32 `path:"noop-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OptionsPresent          *uint32 `path:"options-present" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PacketTooBig            *uint32 `path:"packet-too-big" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PacketsForwarded        *uint32 `path:"packets-forwarded" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PacketsFragmented       *uint32 `path:"packets-fragmented" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PacketsOutput           *uint32 `path:"packets-output" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ReassembleFailed        *uint32 `path:"reassemble-failed" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ReassembleInput         *uint32 `path:"reassemble-input" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ReassembleMaxDrop       *uint32 `path:"reassemble-max-drop" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ReassembleTimeout       *uint32 `path:"reassemble-timeout" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Reassembled             *uint32 `path:"reassembled" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ReceivedPackets         *uint32 `path:"received-packets" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RecordRouteOption       *uint32 `path:"record-route-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RouterAlertOption       *uint32 `path:"router-alert-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	SidOption               *uint32 `path:"sid-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	StrictSourceRouteOption *uint32 `path:"strict-source-route-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	TimestampOption         *uint32 `path:"timestamp-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
	UnknownOption           *uint32 `path:"unknown-option" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics_Traffic_Ipv4Stats) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery struct {
	Nodes *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes `path:"nodes" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) IsYANGGoStruct() {}

// GetOrCreateNodes retrieves the value of the Nodes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) GetOrCreateNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes {
	if t.Nodes != nil {
		return t.Nodes
	}
	t.Nodes = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes{}
	return t.Nodes
}

// GetNodes returns the value of the Nodes struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery. If the receiver or the field Nodes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) GetNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes {
	if t != nil && t.Nodes != nil {
		return t.Nodes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes struct {
	Node map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node `path:"node" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) IsYANGGoStruct() {}

// NewNode creates a new entry in the Node list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) NewNode(NodeName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node)
	}

	key := NodeName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Node[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Node", key)
	}

	t.Node[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node{
		NodeName: &NodeName,
	}

	return t.Node[key], nil
}

// RenameNode renames an entry in the list Node within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) RenameNode(oldK, newK string) error {
	if _, ok := t.Node[newK]; ok {
		return fmt.Errorf("key %v already exists in Node", newK)
	}

	e, ok := t.Node[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Node", oldK)
	}
	e.NodeName = &newK

	t.Node[newK] = e
	delete(t.Node, oldK)
	return nil
}

// GetOrCreateNodeMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) GetOrCreateNodeMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node {
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node)
	}
	return t.Node
}

// GetOrCreateNode retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) GetOrCreateNode(NodeName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node {

	key := NodeName

	if v, ok := t.Node[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNode(NodeName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNode got unexpected error: %v", err))
	}
	return v
}

// GetNode retrieves the value with the specified key from
// the Node map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) GetNode(NodeName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node {

	if t == nil {
		return nil
	}

	key := NodeName

	if lm, ok := t.Node[key]; ok {
		return lm
	}
	return nil
}

// AppendNode appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node struct to the
// list Node of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) AppendNode(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) error {
	if v.NodeName == nil {
		return fmt.Errorf("invalid nil key received for NodeName")
	}

	key := *v.NodeName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node)
	}

	if _, ok := t.Node[key]; ok {
		return fmt.Errorf("duplicate key for list Node %v", key)
	}

	t.Node[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node struct {
	BundleInterfaces   *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces   `path:"bundle-interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	BundleNodes        *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes        `path:"bundle-nodes" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Interfaces         *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces         `path:"interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdVirtualRouters   *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters   `path:"nd-virtual-routers" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NeighborInterfaces *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces `path:"neighbor-interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NeighborSummary    *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary    `path:"neighbor-summary" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NodeName           *string                                                                 `path:"node-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SlaacInterfaces    *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces    `path:"slaac-interfaces" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) IsYANGGoStruct() {}

// GetOrCreateBundleInterfaces retrieves the value of the BundleInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateBundleInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces {
	if t.BundleInterfaces != nil {
		return t.BundleInterfaces
	}
	t.BundleInterfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces{}
	return t.BundleInterfaces
}

// GetOrCreateBundleNodes retrieves the value of the BundleNodes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateBundleNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes {
	if t.BundleNodes != nil {
		return t.BundleNodes
	}
	t.BundleNodes = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes{}
	return t.BundleNodes
}

// GetOrCreateInterfaces retrieves the value of the Interfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces {
	if t.Interfaces != nil {
		return t.Interfaces
	}
	t.Interfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces{}
	return t.Interfaces
}

// GetOrCreateNdVirtualRouters retrieves the value of the NdVirtualRouters field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateNdVirtualRouters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters {
	if t.NdVirtualRouters != nil {
		return t.NdVirtualRouters
	}
	t.NdVirtualRouters = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters{}
	return t.NdVirtualRouters
}

// GetOrCreateNeighborInterfaces retrieves the value of the NeighborInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateNeighborInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces {
	if t.NeighborInterfaces != nil {
		return t.NeighborInterfaces
	}
	t.NeighborInterfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces{}
	return t.NeighborInterfaces
}

// GetOrCreateNeighborSummary retrieves the value of the NeighborSummary field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateNeighborSummary() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary {
	if t.NeighborSummary != nil {
		return t.NeighborSummary
	}
	t.NeighborSummary = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary{}
	return t.NeighborSummary
}

// GetOrCreateSlaacInterfaces retrieves the value of the SlaacInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetOrCreateSlaacInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces {
	if t.SlaacInterfaces != nil {
		return t.SlaacInterfaces
	}
	t.SlaacInterfaces = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces{}
	return t.SlaacInterfaces
}

// GetBundleInterfaces returns the value of the BundleInterfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field BundleInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetBundleInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces {
	if t != nil && t.BundleInterfaces != nil {
		return t.BundleInterfaces
	}
	return nil
}

// GetBundleNodes returns the value of the BundleNodes struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field BundleNodes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetBundleNodes() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes {
	if t != nil && t.BundleNodes != nil {
		return t.BundleNodes
	}
	return nil
}

// GetInterfaces returns the value of the Interfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field Interfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces {
	if t != nil && t.Interfaces != nil {
		return t.Interfaces
	}
	return nil
}

// GetNdVirtualRouters returns the value of the NdVirtualRouters struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field NdVirtualRouters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetNdVirtualRouters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters {
	if t != nil && t.NdVirtualRouters != nil {
		return t.NdVirtualRouters
	}
	return nil
}

// GetNeighborInterfaces returns the value of the NeighborInterfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field NeighborInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetNeighborInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces {
	if t != nil && t.NeighborInterfaces != nil {
		return t.NeighborInterfaces
	}
	return nil
}

// GetNeighborSummary returns the value of the NeighborSummary struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field NeighborSummary is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetNeighborSummary() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary {
	if t != nil && t.NeighborSummary != nil {
		return t.NeighborSummary
	}
	return nil
}

// GetSlaacInterfaces returns the value of the SlaacInterfaces struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node. If the receiver or the field SlaacInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) GetSlaacInterfaces() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces {
	if t != nil && t.SlaacInterfaces != nil {
		return t.SlaacInterfaces
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeName == nil {
		return nil, fmt.Errorf("nil value for key NodeName")
	}

	return map[string]interface{}{
		"node-name": *t.NodeName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces struct {
	BundleInterface map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface `path:"bundle-interface" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) IsYANGGoStruct() {}

// NewBundleInterface creates a new entry in the BundleInterface list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) NewBundleInterface(InterfaceName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BundleInterface == nil {
		t.BundleInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BundleInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BundleInterface", key)
	}

	t.BundleInterface[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface{
		InterfaceName: &InterfaceName,
	}

	return t.BundleInterface[key], nil
}

// RenameBundleInterface renames an entry in the list BundleInterface within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) RenameBundleInterface(oldK, newK string) error {
	if _, ok := t.BundleInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in BundleInterface", newK)
	}

	e, ok := t.BundleInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BundleInterface", oldK)
	}
	e.InterfaceName = &newK

	t.BundleInterface[newK] = e
	delete(t.BundleInterface, oldK)
	return nil
}

// GetOrCreateBundleInterfaceMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) GetOrCreateBundleInterfaceMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface {
	if t.BundleInterface == nil {
		t.BundleInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface)
	}
	return t.BundleInterface
}

// GetOrCreateBundleInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) GetOrCreateBundleInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface {

	key := InterfaceName

	if v, ok := t.BundleInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBundleInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBundleInterface got unexpected error: %v", err))
	}
	return v
}

// GetBundleInterface retrieves the value with the specified key from
// the BundleInterface map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) GetBundleInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.BundleInterface[key]; ok {
		return lm
	}
	return nil
}

// AppendBundleInterface appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface struct to the
// list BundleInterface of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) AppendBundleInterface(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BundleInterface == nil {
		t.BundleInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface)
	}

	if _, ok := t.BundleInterface[key]; ok {
		return fmt.Errorf("duplicate key for list BundleInterface %v", key)
	}

	t.BundleInterface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces/bundle-interface YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface struct {
	Etype               *uint32                                                                                               `path:"etype" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	GlobalAddress       []*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress `path:"global-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Iftype              *uint32                                                                                               `path:"iftype" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	InterfaceName       *string                                                                                               `path:"interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsInterfaceEnabled  *bool                                                                                                 `path:"is-interface-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsIpv6Enabled       *bool                                                                                                 `path:"is-ipv6-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsMplsEnabled       *bool                                                                                                 `path:"is-mpls-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	LocalAddress        *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress    `path:"local-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MacAddr             *string                                                                                               `path:"mac-addr" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MacAddrSize         *uint32                                                                                               `path:"mac-addr-size" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MemberLink          []uint32                                                                                              `path:"member-link" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	MemberNode          []*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode    `path:"member-node" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Mtu                 *uint32                                                                                               `path:"mtu" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdParameters        *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters    `path:"nd-parameters" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ParentInterfaceName *string                                                                                               `path:"parent-interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	VlanTag             *uint16                                                                                               `path:"vlan-tag" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) IsYANGGoStruct() {
}

// GetOrCreateLocalAddress retrieves the value of the LocalAddress field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetOrCreateLocalAddress() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress {
	if t.LocalAddress != nil {
		return t.LocalAddress
	}
	t.LocalAddress = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress{}
	return t.LocalAddress
}

// GetOrCreateNdParameters retrieves the value of the NdParameters field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetOrCreateNdParameters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters {
	if t.NdParameters != nil {
		return t.NdParameters
	}
	t.NdParameters = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters{}
	return t.NdParameters
}

// GetLocalAddress returns the value of the LocalAddress struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface. If the receiver or the field LocalAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetLocalAddress() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress {
	if t != nil && t.LocalAddress != nil {
		return t.LocalAddress
	}
	return nil
}

// GetNdParameters returns the value of the NdParameters struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface. If the receiver or the field NdParameters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) GetNdParameters() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters {
	if t != nil && t.NdParameters != nil {
		return t.NdParameters
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces/bundle-interface/global-address YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress struct {
	Flags         *uint32 `path:"flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Ipv6Address   *string `path:"ipv6-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefLifetime  *uint32 `path:"pref-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefixLength  *uint32 `path:"prefix-length" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ValidLifetime *uint32 `path:"valid-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_GlobalAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces/bundle-interface/local-address YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress struct {
	Flags         *uint32 `path:"flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Ipv6Address   *string `path:"ipv6-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefLifetime  *uint32 `path:"pref-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefixLength  *uint32 `path:"prefix-length" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ValidLifetime *uint32 `path:"valid-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_LocalAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces/bundle-interface/member-node YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode struct {
	NodeName   *string `path:"node-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	TotalLinks *uint32 `path:"total-links" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_MemberNode) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-interfaces/bundle-interface/nd-parameters YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters struct {
	CompleteGleanCount      *uint32 `path:"complete-glean-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	CompleteProtocolCount   *uint32 `path:"complete-protocol-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DadAttempts             *uint32 `path:"dad-attempts" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DroppedGleanReqCount    *uint32 `path:"dropped-glean-req-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DroppedProtocolReqCount *uint32 `path:"dropped-protocol-req-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteGleanCount    *uint32 `path:"incomplete-glean-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteProtocolCount *uint32 `path:"incomplete-protocol-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsDadEnabled            *bool   `path:"is-dad-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsDhcpManaged           *bool   `path:"is-dhcp-managed" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsIcmPv6Redirect        *bool   `path:"is-icm-pv6-redirect" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsRouteAddressManaged   *bool   `path:"is-route-address-managed" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsSuppressed            *bool   `path:"is-suppressed" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdAdvertisementLifetime *uint32 `path:"nd-advertisement-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdCacheLimit            *uint32 `path:"nd-cache-limit" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdMaxTransmitInterval   *uint32 `path:"nd-max-transmit-interval" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdMinTransmitInterval   *uint32 `path:"nd-min-transmit-interval" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdReachableTime         *uint32 `path:"nd-reachable-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdRetransmitInterval    *uint32 `path:"nd-retransmit-interval" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	RadnsSearchListCount    *uint32 `path:"radns-search-list-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	RadnsServerAddressCount *uint32 `path:"radns-server-address-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SendUnicastRa           *bool   `path:"send-unicast-ra" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleInterfaces_BundleInterface_NdParameters) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-nodes YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes struct {
	BundleNode map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode `path:"bundle-node" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) IsYANGGoStruct() {}

// NewBundleNode creates a new entry in the BundleNode list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) NewBundleNode(NodeName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BundleNode == nil {
		t.BundleNode = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode)
	}

	key := NodeName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BundleNode[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BundleNode", key)
	}

	t.BundleNode[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode{
		NodeName: &NodeName,
	}

	return t.BundleNode[key], nil
}

// RenameBundleNode renames an entry in the list BundleNode within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) RenameBundleNode(oldK, newK string) error {
	if _, ok := t.BundleNode[newK]; ok {
		return fmt.Errorf("key %v already exists in BundleNode", newK)
	}

	e, ok := t.BundleNode[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BundleNode", oldK)
	}
	e.NodeName = &newK

	t.BundleNode[newK] = e
	delete(t.BundleNode, oldK)
	return nil
}

// GetOrCreateBundleNodeMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) GetOrCreateBundleNodeMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode {
	if t.BundleNode == nil {
		t.BundleNode = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode)
	}
	return t.BundleNode
}

// GetOrCreateBundleNode retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) GetOrCreateBundleNode(NodeName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode {

	key := NodeName

	if v, ok := t.BundleNode[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBundleNode(NodeName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBundleNode got unexpected error: %v", err))
	}
	return v
}

// GetBundleNode retrieves the value with the specified key from
// the BundleNode map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) GetBundleNode(NodeName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode {

	if t == nil {
		return nil
	}

	key := NodeName

	if lm, ok := t.BundleNode[key]; ok {
		return lm
	}
	return nil
}

// AppendBundleNode appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode struct to the
// list BundleNode of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) AppendBundleNode(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) error {
	if v.NodeName == nil {
		return fmt.Errorf("invalid nil key received for NodeName")
	}

	key := *v.NodeName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BundleNode == nil {
		t.BundleNode = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode)
	}

	if _, ok := t.BundleNode[key]; ok {
		return fmt.Errorf("duplicate key for list BundleNode %v", key)
	}

	t.BundleNode[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-nodes/bundle-node YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode struct {
	Age                    *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age `path:"age" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	GroupId                *uint32                                                                         `path:"group-id" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NodeName               *string                                                                         `path:"node-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ProcessName            *string                                                                         `path:"process-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReceivedPackets        *uint32                                                                         `path:"received-packets" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReceivedSequenceNumber *uint32                                                                         `path:"received-sequence-number" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SentPackets            *uint32                                                                         `path:"sent-packets" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SentSequenceNumber     *uint32                                                                         `path:"sent-sequence-number" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	State                  E_Cisco_IOS_XRIpv6NdOper_Ipv6NdBndlState                                        `path:"state" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StateChanges           *uint32                                                                         `path:"state-changes" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) IsYANGGoStruct() {}

// GetOrCreateAge retrieves the value of the Age field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) GetOrCreateAge() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age {
	if t.Age != nil {
		return t.Age
	}
	t.Age = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age{}
	return t.Age
}

// GetAge returns the value of the Age struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode. If the receiver or the field Age is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) GetAge() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age {
	if t != nil && t.Age != nil {
		return t.Age
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeName == nil {
		return nil, fmt.Errorf("nil value for key NodeName")
	}

	return map[string]interface{}{
		"node-name": *t.NodeName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/bundle-nodes/bundle-node/age YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age struct {
	Seconds *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_BundleNodes_BundleNode_Age) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/interfaces YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces struct {
	Interface map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface `path:"interface" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) NewInterface(InterfaceName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface{
		InterfaceName: &InterfaceName,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceName = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) GetOrCreateInterfaceMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) GetOrCreateInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface {

	key := InterfaceName

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) GetInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface struct to the
// list Interface of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) AppendInterface(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/interfaces/interface YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface struct {
	CompleteGleanCount      *uint32 `path:"complete-glean-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	CompleteProtocolCount   *uint32 `path:"complete-protocol-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DadAttempts             *uint32 `path:"dad-attempts" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DroppedGleanReqCount    *uint32 `path:"dropped-glean-req-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DroppedProtocolReqCount *uint32 `path:"dropped-protocol-req-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteGleanCount    *uint32 `path:"incomplete-glean-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteProtocolCount *uint32 `path:"incomplete-protocol-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	InterfaceName           *string `path:"interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsDadEnabled            *bool   `path:"is-dad-enabled" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsDhcpManaged           *bool   `path:"is-dhcp-managed" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsIcmPv6Redirect        *bool   `path:"is-icm-pv6-redirect" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsRouteAddressManaged   *bool   `path:"is-route-address-managed" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsSuppressed            *bool   `path:"is-suppressed" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdAdvertisementLifetime *uint32 `path:"nd-advertisement-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdCacheLimit            *uint32 `path:"nd-cache-limit" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdMaxTransmitInterval   *uint32 `path:"nd-max-transmit-interval" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdMinTransmitInterval   *uint32 `path:"nd-min-transmit-interval" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdReachableTime         *uint32 `path:"nd-reachable-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	NdRetransmitInterval    *uint32 `path:"nd-retransmit-interval" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	RadnsSearchListCount    *uint32 `path:"radns-search-list-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	RadnsServerAddressCount *uint32 `path:"radns-server-address-count" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SendUnicastRa           *bool   `path:"send-unicast-ra" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_Interfaces_Interface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/nd-virtual-routers YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters struct {
	NdVirtualRouter map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter `path:"nd-virtual-router" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) IsYANGGoStruct() {}

// NewNdVirtualRouter creates a new entry in the NdVirtualRouter list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) NewNdVirtualRouter(InterfaceName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NdVirtualRouter == nil {
		t.NdVirtualRouter = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NdVirtualRouter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NdVirtualRouter", key)
	}

	t.NdVirtualRouter[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter{
		InterfaceName: &InterfaceName,
	}

	return t.NdVirtualRouter[key], nil
}

// RenameNdVirtualRouter renames an entry in the list NdVirtualRouter within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) RenameNdVirtualRouter(oldK, newK string) error {
	if _, ok := t.NdVirtualRouter[newK]; ok {
		return fmt.Errorf("key %v already exists in NdVirtualRouter", newK)
	}

	e, ok := t.NdVirtualRouter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NdVirtualRouter", oldK)
	}
	e.InterfaceName = &newK

	t.NdVirtualRouter[newK] = e
	delete(t.NdVirtualRouter, oldK)
	return nil
}

// GetOrCreateNdVirtualRouterMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) GetOrCreateNdVirtualRouterMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter {
	if t.NdVirtualRouter == nil {
		t.NdVirtualRouter = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter)
	}
	return t.NdVirtualRouter
}

// GetOrCreateNdVirtualRouter retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) GetOrCreateNdVirtualRouter(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter {

	key := InterfaceName

	if v, ok := t.NdVirtualRouter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNdVirtualRouter(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNdVirtualRouter got unexpected error: %v", err))
	}
	return v
}

// GetNdVirtualRouter retrieves the value with the specified key from
// the NdVirtualRouter map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) GetNdVirtualRouter(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.NdVirtualRouter[key]; ok {
		return lm
	}
	return nil
}

// AppendNdVirtualRouter appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter struct to the
// list NdVirtualRouter of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) AppendNdVirtualRouter(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NdVirtualRouter == nil {
		t.NdVirtualRouter = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter)
	}

	if _, ok := t.NdVirtualRouter[key]; ok {
		return fmt.Errorf("duplicate key for list NdVirtualRouter %v", key)
	}

	t.NdVirtualRouter[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/nd-virtual-routers/nd-virtual-router YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter struct {
	Context          *uint32                                                                                                 `path:"context" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Flags            E_Cisco_IOS_XRIpv6NdOper_Ipv6NdShVrFlags                                                                `path:"flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	InterfaceName    *string                                                                                                 `path:"interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	LinkLayerAddress *string                                                                                                 `path:"link-layer-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	LocalAddress     *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress      `path:"local-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	State            E_Cisco_IOS_XRIpv6NdOper_Ipv6NdShVrState                                                                `path:"state" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	VrGlAddrCt       *uint32                                                                                                 `path:"vr-gl-addr-ct" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	VrGlobalAddress  []*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress `path:"vr-global-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) IsYANGGoStruct() {
}

// GetOrCreateLocalAddress retrieves the value of the LocalAddress field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) GetOrCreateLocalAddress() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress {
	if t.LocalAddress != nil {
		return t.LocalAddress
	}
	t.LocalAddress = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress{}
	return t.LocalAddress
}

// GetLocalAddress returns the value of the LocalAddress struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter. If the receiver or the field LocalAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) GetLocalAddress() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress {
	if t != nil && t.LocalAddress != nil {
		return t.LocalAddress
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/nd-virtual-routers/nd-virtual-router/local-address YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress struct {
	Flags         *uint32 `path:"flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Ipv6Address   *string `path:"ipv6-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefLifetime  *uint32 `path:"pref-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefixLength  *uint32 `path:"prefix-length" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ValidLifetime *uint32 `path:"valid-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_LocalAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/nd-virtual-routers/nd-virtual-router/vr-global-address YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress struct {
	Flags         *uint32 `path:"flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Ipv6Address   *string `path:"ipv6-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefLifetime  *uint32 `path:"pref-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefixLength  *uint32 `path:"prefix-length" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ValidLifetime *uint32 `path:"valid-lifetime" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NdVirtualRouters_NdVirtualRouter_VrGlobalAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-interfaces YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces struct {
	NeighborInterface map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface `path:"neighbor-interface" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) IsYANGGoStruct() {}

// NewNeighborInterface creates a new entry in the NeighborInterface list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) NewNeighborInterface(InterfaceName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NeighborInterface == nil {
		t.NeighborInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NeighborInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NeighborInterface", key)
	}

	t.NeighborInterface[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface{
		InterfaceName: &InterfaceName,
	}

	return t.NeighborInterface[key], nil
}

// RenameNeighborInterface renames an entry in the list NeighborInterface within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) RenameNeighborInterface(oldK, newK string) error {
	if _, ok := t.NeighborInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in NeighborInterface", newK)
	}

	e, ok := t.NeighborInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NeighborInterface", oldK)
	}
	e.InterfaceName = &newK

	t.NeighborInterface[newK] = e
	delete(t.NeighborInterface, oldK)
	return nil
}

// GetOrCreateNeighborInterfaceMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) GetOrCreateNeighborInterfaceMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface {
	if t.NeighborInterface == nil {
		t.NeighborInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface)
	}
	return t.NeighborInterface
}

// GetOrCreateNeighborInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) GetOrCreateNeighborInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface {

	key := InterfaceName

	if v, ok := t.NeighborInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNeighborInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNeighborInterface got unexpected error: %v", err))
	}
	return v
}

// GetNeighborInterface retrieves the value with the specified key from
// the NeighborInterface map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) GetNeighborInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.NeighborInterface[key]; ok {
		return lm
	}
	return nil
}

// AppendNeighborInterface appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface struct to the
// list NeighborInterface of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) AppendNeighborInterface(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NeighborInterface == nil {
		t.NeighborInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface)
	}

	if _, ok := t.NeighborInterface[key]; ok {
		return fmt.Errorf("duplicate key for list NeighborInterface %v", key)
	}

	t.NeighborInterface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface struct {
	HostAddresses *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses `path:"host-addresses" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	InterfaceName *string                                                                                                 `path:"interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) IsYANGGoStruct() {
}

// GetOrCreateHostAddresses retrieves the value of the HostAddresses field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) GetOrCreateHostAddresses() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses {
	if t.HostAddresses != nil {
		return t.HostAddresses
	}
	t.HostAddresses = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses{}
	return t.HostAddresses
}

// GetHostAddresses returns the value of the HostAddresses struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface. If the receiver or the field HostAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) GetHostAddresses() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses {
	if t != nil && t.HostAddresses != nil {
		return t.HostAddresses
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses struct {
	HostAddress map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress `path:"host-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) IsYANGGoStruct() {
}

// NewHostAddress creates a new entry in the HostAddress list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) NewHostAddress(HostAddress string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostAddress == nil {
		t.HostAddress = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress)
	}

	key := HostAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.HostAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list HostAddress", key)
	}

	t.HostAddress[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress{
		HostAddress: &HostAddress,
	}

	return t.HostAddress[key], nil
}

// RenameHostAddress renames an entry in the list HostAddress within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) RenameHostAddress(oldK, newK string) error {
	if _, ok := t.HostAddress[newK]; ok {
		return fmt.Errorf("key %v already exists in HostAddress", newK)
	}

	e, ok := t.HostAddress[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in HostAddress", oldK)
	}
	e.HostAddress = &newK

	t.HostAddress[newK] = e
	delete(t.HostAddress, oldK)
	return nil
}

// GetOrCreateHostAddressMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) GetOrCreateHostAddressMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress {
	if t.HostAddress == nil {
		t.HostAddress = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress)
	}
	return t.HostAddress
}

// GetOrCreateHostAddress retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) GetOrCreateHostAddress(HostAddress string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress {

	key := HostAddress

	if v, ok := t.HostAddress[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHostAddress(HostAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHostAddress got unexpected error: %v", err))
	}
	return v
}

// GetHostAddress retrieves the value with the specified key from
// the HostAddress map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) GetHostAddress(HostAddress string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress {

	if t == nil {
		return nil
	}

	key := HostAddress

	if lm, ok := t.HostAddress[key]; ok {
		return lm
	}
	return nil
}

// AppendHostAddress appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress struct to the
// list HostAddress of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) AppendHostAddress(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) error {
	if v.HostAddress == nil {
		return fmt.Errorf("invalid nil key received for HostAddress")
	}

	key := *v.HostAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.HostAddress == nil {
		t.HostAddress = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress)
	}

	if _, ok := t.HostAddress[key]; ok {
		return fmt.Errorf("duplicate key for list HostAddress %v", key)
	}

	t.HostAddress[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress struct {
	Encapsulation         E_Cisco_IOS_XRIpv6NdOper_Ipv6NdMediaEncap                                                                                           `path:"encapsulation" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	HostAddress           *string                                                                                                                             `path:"host-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	InterfaceName         *string                                                                                                                             `path:"interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IsRouter              *bool                                                                                                                               `path:"is-router" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	LastReachedTime       *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime `path:"last-reached-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	LinkLayerAddress      *string                                                                                                                             `path:"link-layer-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Location              *string                                                                                                                             `path:"location" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	OriginEncapsulation   E_Cisco_IOS_XRIpv6NdOper_Ipv6NdNeighborOrigin                                                                                       `path:"origin-encapsulation" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachabilityState     E_Cisco_IOS_XRIpv6NdOper_Ipv6NdShState                                                                                              `path:"reachability-state" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SelectedEncapsulation E_Cisco_IOS_XRIpv6NdOper_Ipv6NdMediaEncap                                                                                           `path:"selected-encapsulation" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SergFlags             *uint32                                                                                                                             `path:"serg-flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Vrfid                 *uint32                                                                                                                             `path:"vrfid" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) IsYANGGoStruct() {
}

// GetOrCreateLastReachedTime retrieves the value of the LastReachedTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) GetOrCreateLastReachedTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime {
	if t.LastReachedTime != nil {
		return t.LastReachedTime
	}
	t.LastReachedTime = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime{}
	return t.LastReachedTime
}

// GetLastReachedTime returns the value of the LastReachedTime struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress. If the receiver or the field LastReachedTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) GetLastReachedTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime {
	if t != nil && t.LastReachedTime != nil {
		return t.LastReachedTime
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.HostAddress == nil {
		return nil, fmt.Errorf("nil value for key HostAddress")
	}

	return map[string]interface{}{
		"host-address": *t.HostAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-interfaces/neighbor-interface/host-addresses/host-address/last-reached-time YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime struct {
	Seconds *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborInterfaces_NeighborInterface_HostAddresses_HostAddress_LastReachedTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-summary YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary struct {
	Dynamic              *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic     `path:"dynamic" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DynamicSync          *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync `path:"dynamic-sync" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Multicast            *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast   `path:"multicast" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Static               *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static      `path:"static" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StaticSync           *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync  `path:"static-sync" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Sync                 *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync        `path:"sync" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	TotalNeighborEntries *uint32                                                                          `path:"total-neighbor-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) IsYANGGoStruct() {}

// GetOrCreateDynamic retrieves the value of the Dynamic field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetOrCreateDynamic() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic {
	if t.Dynamic != nil {
		return t.Dynamic
	}
	t.Dynamic = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic{}
	return t.Dynamic
}

// GetOrCreateDynamicSync retrieves the value of the DynamicSync field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetOrCreateDynamicSync() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync {
	if t.DynamicSync != nil {
		return t.DynamicSync
	}
	t.DynamicSync = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync{}
	return t.DynamicSync
}

// GetOrCreateMulticast retrieves the value of the Multicast field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetOrCreateMulticast() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast {
	if t.Multicast != nil {
		return t.Multicast
	}
	t.Multicast = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast{}
	return t.Multicast
}

// GetOrCreateStatic retrieves the value of the Static field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetOrCreateStatic() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static {
	if t.Static != nil {
		return t.Static
	}
	t.Static = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static{}
	return t.Static
}

// GetOrCreateStaticSync retrieves the value of the StaticSync field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetOrCreateStaticSync() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync {
	if t.StaticSync != nil {
		return t.StaticSync
	}
	t.StaticSync = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync{}
	return t.StaticSync
}

// GetOrCreateSync retrieves the value of the Sync field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetOrCreateSync() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync {
	if t.Sync != nil {
		return t.Sync
	}
	t.Sync = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync{}
	return t.Sync
}

// GetDynamic returns the value of the Dynamic struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary. If the receiver or the field Dynamic is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetDynamic() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic {
	if t != nil && t.Dynamic != nil {
		return t.Dynamic
	}
	return nil
}

// GetDynamicSync returns the value of the DynamicSync struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary. If the receiver or the field DynamicSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetDynamicSync() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync {
	if t != nil && t.DynamicSync != nil {
		return t.DynamicSync
	}
	return nil
}

// GetMulticast returns the value of the Multicast struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary. If the receiver or the field Multicast is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetMulticast() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast {
	if t != nil && t.Multicast != nil {
		return t.Multicast
	}
	return nil
}

// GetStatic returns the value of the Static struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary. If the receiver or the field Static is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetStatic() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static {
	if t != nil && t.Static != nil {
		return t.Static
	}
	return nil
}

// GetStaticSync returns the value of the StaticSync struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary. If the receiver or the field StaticSync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetStaticSync() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync {
	if t != nil && t.StaticSync != nil {
		return t.StaticSync
	}
	return nil
}

// GetSync returns the value of the Sync struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary. If the receiver or the field Sync is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) GetSync() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync {
	if t != nil && t.Sync != nil {
		return t.Sync
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-summary/dynamic YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic struct {
	DelayedEntries          *uint32 `path:"delayed-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DeletedEntries          *uint32 `path:"deleted-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteEntries       *uint32 `path:"incomplete-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ProbeEntries            *uint32 `path:"probe-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachableEntries        *uint32 `path:"reachable-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StaleEntries            *uint32 `path:"stale-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SubtotalNeighborEntries *uint32 `path:"subtotal-neighbor-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Dynamic) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-summary/dynamic-sync YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync struct {
	DelayedEntries          *uint32 `path:"delayed-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DeletedEntries          *uint32 `path:"deleted-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteEntries       *uint32 `path:"incomplete-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ProbeEntries            *uint32 `path:"probe-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachableEntries        *uint32 `path:"reachable-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StaleEntries            *uint32 `path:"stale-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SubtotalNeighborEntries *uint32 `path:"subtotal-neighbor-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_DynamicSync) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-summary/multicast YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast struct {
	DelayedEntries          *uint32 `path:"delayed-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DeletedEntries          *uint32 `path:"deleted-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteEntries       *uint32 `path:"incomplete-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ProbeEntries            *uint32 `path:"probe-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachableEntries        *uint32 `path:"reachable-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StaleEntries            *uint32 `path:"stale-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SubtotalNeighborEntries *uint32 `path:"subtotal-neighbor-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Multicast) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-summary/static YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static struct {
	DelayedEntries          *uint32 `path:"delayed-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DeletedEntries          *uint32 `path:"deleted-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteEntries       *uint32 `path:"incomplete-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ProbeEntries            *uint32 `path:"probe-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachableEntries        *uint32 `path:"reachable-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StaleEntries            *uint32 `path:"stale-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SubtotalNeighborEntries *uint32 `path:"subtotal-neighbor-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Static) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-summary/static-sync YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync struct {
	DelayedEntries          *uint32 `path:"delayed-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DeletedEntries          *uint32 `path:"deleted-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteEntries       *uint32 `path:"incomplete-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ProbeEntries            *uint32 `path:"probe-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachableEntries        *uint32 `path:"reachable-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StaleEntries            *uint32 `path:"stale-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SubtotalNeighborEntries *uint32 `path:"subtotal-neighbor-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_StaticSync) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/neighbor-summary/sync YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync struct {
	DelayedEntries          *uint32 `path:"delayed-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DeletedEntries          *uint32 `path:"deleted-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	IncompleteEntries       *uint32 `path:"incomplete-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ProbeEntries            *uint32 `path:"probe-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachableEntries        *uint32 `path:"reachable-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	StaleEntries            *uint32 `path:"stale-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	SubtotalNeighborEntries *uint32 `path:"subtotal-neighbor-entries" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_NeighborSummary_Sync) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces struct {
	SlaacInterface map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface `path:"slaac-interface" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) IsYANGGoStruct() {}

// NewSlaacInterface creates a new entry in the SlaacInterface list of the
// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) NewSlaacInterface(InterfaceName string) (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SlaacInterface == nil {
		t.SlaacInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SlaacInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SlaacInterface", key)
	}

	t.SlaacInterface[key] = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface{
		InterfaceName: &InterfaceName,
	}

	return t.SlaacInterface[key], nil
}

// RenameSlaacInterface renames an entry in the list SlaacInterface within
// the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) RenameSlaacInterface(oldK, newK string) error {
	if _, ok := t.SlaacInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in SlaacInterface", newK)
	}

	e, ok := t.SlaacInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SlaacInterface", oldK)
	}
	e.InterfaceName = &newK

	t.SlaacInterface[newK] = e
	delete(t.SlaacInterface, oldK)
	return nil
}

// GetOrCreateSlaacInterfaceMap returns the list (map) from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) GetOrCreateSlaacInterfaceMap() map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface {
	if t.SlaacInterface == nil {
		t.SlaacInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface)
	}
	return t.SlaacInterface
}

// GetOrCreateSlaacInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) GetOrCreateSlaacInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface {

	key := InterfaceName

	if v, ok := t.SlaacInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSlaacInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSlaacInterface got unexpected error: %v", err))
	}
	return v
}

// GetSlaacInterface retrieves the value with the specified key from
// the SlaacInterface map field of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) GetSlaacInterface(InterfaceName string) *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.SlaacInterface[key]; ok {
		return lm
	}
	return nil
}

// AppendSlaacInterface appends the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface struct to the
// list SlaacInterface of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) AppendSlaacInterface(v *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SlaacInterface == nil {
		t.SlaacInterface = make(map[string]*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface)
	}

	if _, ok := t.SlaacInterface[key]; ok {
		return fmt.Errorf("duplicate key for list SlaacInterface %v", key)
	}

	t.SlaacInterface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces/slaac-interface YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface struct {
	InterfaceName      *string                                                                                                `path:"interface-name" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	RouterAdvertDetail *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail `path:"router-advert-detail" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) IsYANGGoStruct() {
}

// GetOrCreateRouterAdvertDetail retrieves the value of the RouterAdvertDetail field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) GetOrCreateRouterAdvertDetail() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail {
	if t.RouterAdvertDetail != nil {
		return t.RouterAdvertDetail
	}
	t.RouterAdvertDetail = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail{}
	return t.RouterAdvertDetail
}

// GetRouterAdvertDetail returns the value of the RouterAdvertDetail struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface. If the receiver or the field RouterAdvertDetail is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) GetRouterAdvertDetail() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail {
	if t != nil && t.RouterAdvertDetail != nil {
		return t.RouterAdvertDetail
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces/slaac-interface/router-advert-detail YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail struct {
	Idb *string                                                                                                     `path:"idb" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Ra  []*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra `path:"ra" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces/slaac-interface/router-advert-detail/ra YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra struct {
	Address       *string                                                                                                                 `path:"address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	DefaultRouter *bool                                                                                                                   `path:"default-router" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ElapsedRaTime *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime `path:"elapsed-ra-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ErrMsg        *bool                                                                                                                   `path:"err-msg" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Flags         *uint32                                                                                                                 `path:"flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Hops          *uint32                                                                                                                 `path:"hops" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	LifeTime      *uint32                                                                                                                 `path:"life-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Mtu           *uint32                                                                                                                 `path:"mtu" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefixQ       []*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ     `path:"prefix-q" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Reachability  *uint32                                                                                                                 `path:"reachability" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ReachableTime *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime `path:"reachable-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	RetransTime   *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime   `path:"retrans-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	RibProtoid    *uint16                                                                                                                 `path:"rib-protoid" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	U6TblId       *uint32                                                                                                                 `path:"u6-tbl-id" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	VrfId         *uint32                                                                                                                 `path:"vrf-id" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) IsYANGGoStruct() {
}

// GetOrCreateElapsedRaTime retrieves the value of the ElapsedRaTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) GetOrCreateElapsedRaTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime {
	if t.ElapsedRaTime != nil {
		return t.ElapsedRaTime
	}
	t.ElapsedRaTime = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime{}
	return t.ElapsedRaTime
}

// GetOrCreateReachableTime retrieves the value of the ReachableTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) GetOrCreateReachableTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime {
	if t.ReachableTime != nil {
		return t.ReachableTime
	}
	t.ReachableTime = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime{}
	return t.ReachableTime
}

// GetOrCreateRetransTime retrieves the value of the RetransTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) GetOrCreateRetransTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime {
	if t.RetransTime != nil {
		return t.RetransTime
	}
	t.RetransTime = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime{}
	return t.RetransTime
}

// GetElapsedRaTime returns the value of the ElapsedRaTime struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra. If the receiver or the field ElapsedRaTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) GetElapsedRaTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime {
	if t != nil && t.ElapsedRaTime != nil {
		return t.ElapsedRaTime
	}
	return nil
}

// GetReachableTime returns the value of the ReachableTime struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra. If the receiver or the field ReachableTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) GetReachableTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime {
	if t != nil && t.ReachableTime != nil {
		return t.ReachableTime
	}
	return nil
}

// GetRetransTime returns the value of the RetransTime struct pointer
// from Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra. If the receiver or the field RetransTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) GetRetransTime() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime {
	if t != nil && t.RetransTime != nil {
		return t.RetransTime
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces/slaac-interface/router-advert-detail/ra/elapsed-ra-time YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime struct {
	Seconds *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ElapsedRaTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces/slaac-interface/router-advert-detail/ra/prefix-q YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ struct {
	Eui64             *string `path:"eui64" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	Flags             *uint32 `path:"flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PfxFlags          *uint32 `path:"pfx-flags" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PreferredLifeTime *uint32 `path:"preferred-life-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefixAddress     *string `path:"prefix-address" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	PrefixLen         *uint32 `path:"prefix-len" module:"Cisco-IOS-XR-ipv6-nd-oper"`
	ValidLifeTime     *uint32 `path:"valid-life-time" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_PrefixQ) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces/slaac-interface/router-advert-detail/ra/reachable-time YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime struct {
	Seconds *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_ReachableTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime represents the /Cisco-IOS-XR-ipv6-nd-oper/ipv6-node-discovery/nodes/node/slaac-interfaces/slaac-interface/router-advert-detail/ra/retrans-time YANG schema element.
type Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime struct {
	Seconds *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime.
func (*Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery_Nodes_Node_SlaacInterfaces_SlaacInterface_RouterAdvertDetail_Ra_RetransTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv6-nd-oper"
}

// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate represents the /Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg/dynamic-template YANG schema element.
type Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate struct {
	IpSubscribers      *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers      `path:"ip-subscribers" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
	Ppps               *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps               `path:"ppps" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
	SubscriberServices *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices `path:"subscriber-services" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) IsYANGGoStruct() {}

// GetOrCreateIpSubscribers retrieves the value of the IpSubscribers field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) GetOrCreateIpSubscribers() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers {
	if t.IpSubscribers != nil {
		return t.IpSubscribers
	}
	t.IpSubscribers = &Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers{}
	return t.IpSubscribers
}

// GetOrCreatePpps retrieves the value of the Ppps field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) GetOrCreatePpps() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps {
	if t.Ppps != nil {
		return t.Ppps
	}
	t.Ppps = &Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps{}
	return t.Ppps
}

// GetOrCreateSubscriberServices retrieves the value of the SubscriberServices field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) GetOrCreateSubscriberServices() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices {
	if t.SubscriberServices != nil {
		return t.SubscriberServices
	}
	t.SubscriberServices = &Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices{}
	return t.SubscriberServices
}

// GetIpSubscribers returns the value of the IpSubscribers struct pointer
// from Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate. If the receiver or the field IpSubscribers is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) GetIpSubscribers() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers {
	if t != nil && t.IpSubscribers != nil {
		return t.IpSubscribers
	}
	return nil
}

// GetPpps returns the value of the Ppps struct pointer
// from Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate. If the receiver or the field Ppps is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) GetPpps() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps {
	if t != nil && t.Ppps != nil {
		return t.Ppps
	}
	return nil
}

// GetSubscriberServices returns the value of the SubscriberServices struct pointer
// from Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate. If the receiver or the field SubscriberServices is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) GetSubscriberServices() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices {
	if t != nil && t.SubscriberServices != nil {
		return t.SubscriberServices
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate) ΛBelongingModule() string {
	return "Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"
}

// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers represents the /Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg/dynamic-template/ip-subscribers YANG schema element.
type Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers struct {
	IpSubscriber map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber `path:"ip-subscriber" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) IsYANGGoStruct() {}

// NewIpSubscriber creates a new entry in the IpSubscriber list of the
// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) NewIpSubscriber(TemplateName string) (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpSubscriber == nil {
		t.IpSubscriber = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber)
	}

	key := TemplateName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IpSubscriber[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IpSubscriber", key)
	}

	t.IpSubscriber[key] = &Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber{
		TemplateName: &TemplateName,
	}

	return t.IpSubscriber[key], nil
}

// RenameIpSubscriber renames an entry in the list IpSubscriber within
// the Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) RenameIpSubscriber(oldK, newK string) error {
	if _, ok := t.IpSubscriber[newK]; ok {
		return fmt.Errorf("key %v already exists in IpSubscriber", newK)
	}

	e, ok := t.IpSubscriber[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IpSubscriber", oldK)
	}
	e.TemplateName = &newK

	t.IpSubscriber[newK] = e
	delete(t.IpSubscriber, oldK)
	return nil
}

// GetOrCreateIpSubscriberMap returns the list (map) from Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) GetOrCreateIpSubscriberMap() map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber {
	if t.IpSubscriber == nil {
		t.IpSubscriber = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber)
	}
	return t.IpSubscriber
}

// GetOrCreateIpSubscriber retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) GetOrCreateIpSubscriber(TemplateName string) *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber {

	key := TemplateName

	if v, ok := t.IpSubscriber[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpSubscriber(TemplateName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpSubscriber got unexpected error: %v", err))
	}
	return v
}

// GetIpSubscriber retrieves the value with the specified key from
// the IpSubscriber map field of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) GetIpSubscriber(TemplateName string) *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber {

	if t == nil {
		return nil
	}

	key := TemplateName

	if lm, ok := t.IpSubscriber[key]; ok {
		return lm
	}
	return nil
}

// AppendIpSubscriber appends the supplied Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber struct to the
// list IpSubscriber of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers. If the key value(s) specified in
// the supplied Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) AppendIpSubscriber(v *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber) error {
	if v.TemplateName == nil {
		return fmt.Errorf("invalid nil key received for TemplateName")
	}

	key := *v.TemplateName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpSubscriber == nil {
		t.IpSubscriber = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber)
	}

	if _, ok := t.IpSubscriber[key]; ok {
		return fmt.Errorf("duplicate key for list IpSubscriber %v", key)
	}

	t.IpSubscriber[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers) ΛBelongingModule() string {
	return "Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"
}

// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber represents the /Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg/dynamic-template/ip-subscribers/ip-subscriber YANG schema element.
type Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber struct {
	TemplateName *string `path:"template-name" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber struct, which is a YANG list entry.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber) ΛListKeyMap() (map[string]interface{}, error) {
	if t.TemplateName == nil {
		return nil, fmt.Errorf("nil value for key TemplateName")
	}

	return map[string]interface{}{
		"template-name": *t.TemplateName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_IpSubscribers_IpSubscriber) ΛBelongingModule() string {
	return "Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"
}

// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps represents the /Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg/dynamic-template/ppps YANG schema element.
type Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps struct {
	Ppp map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp `path:"ppp" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) IsYANGGoStruct() {}

// NewPpp creates a new entry in the Ppp list of the
// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) NewPpp(TemplateName string) (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ppp == nil {
		t.Ppp = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp)
	}

	key := TemplateName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ppp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ppp", key)
	}

	t.Ppp[key] = &Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp{
		TemplateName: &TemplateName,
	}

	return t.Ppp[key], nil
}

// RenamePpp renames an entry in the list Ppp within
// the Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) RenamePpp(oldK, newK string) error {
	if _, ok := t.Ppp[newK]; ok {
		return fmt.Errorf("key %v already exists in Ppp", newK)
	}

	e, ok := t.Ppp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ppp", oldK)
	}
	e.TemplateName = &newK

	t.Ppp[newK] = e
	delete(t.Ppp, oldK)
	return nil
}

// GetOrCreatePppMap returns the list (map) from Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) GetOrCreatePppMap() map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp {
	if t.Ppp == nil {
		t.Ppp = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp)
	}
	return t.Ppp
}

// GetOrCreatePpp retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) GetOrCreatePpp(TemplateName string) *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp {

	key := TemplateName

	if v, ok := t.Ppp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPpp(TemplateName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePpp got unexpected error: %v", err))
	}
	return v
}

// GetPpp retrieves the value with the specified key from
// the Ppp map field of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) GetPpp(TemplateName string) *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp {

	if t == nil {
		return nil
	}

	key := TemplateName

	if lm, ok := t.Ppp[key]; ok {
		return lm
	}
	return nil
}

// AppendPpp appends the supplied Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp struct to the
// list Ppp of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps. If the key value(s) specified in
// the supplied Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) AppendPpp(v *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp) error {
	if v.TemplateName == nil {
		return fmt.Errorf("invalid nil key received for TemplateName")
	}

	key := *v.TemplateName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ppp == nil {
		t.Ppp = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp)
	}

	if _, ok := t.Ppp[key]; ok {
		return fmt.Errorf("duplicate key for list Ppp %v", key)
	}

	t.Ppp[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps) ΛBelongingModule() string {
	return "Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"
}

// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp represents the /Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg/dynamic-template/ppps/ppp YANG schema element.
type Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp struct {
	TemplateName *string `path:"template-name" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp struct, which is a YANG list entry.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp) ΛListKeyMap() (map[string]interface{}, error) {
	if t.TemplateName == nil {
		return nil, fmt.Errorf("nil value for key TemplateName")
	}

	return map[string]interface{}{
		"template-name": *t.TemplateName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_Ppps_Ppp) ΛBelongingModule() string {
	return "Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"
}

// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices represents the /Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg/dynamic-template/subscriber-services YANG schema element.
type Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices struct {
	SubscriberService map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService `path:"subscriber-service" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) IsYANGGoStruct() {}

// NewSubscriberService creates a new entry in the SubscriberService list of the
// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) NewSubscriberService(TemplateName string) (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SubscriberService == nil {
		t.SubscriberService = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService)
	}

	key := TemplateName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SubscriberService[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SubscriberService", key)
	}

	t.SubscriberService[key] = &Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService{
		TemplateName: &TemplateName,
	}

	return t.SubscriberService[key], nil
}

// RenameSubscriberService renames an entry in the list SubscriberService within
// the Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) RenameSubscriberService(oldK, newK string) error {
	if _, ok := t.SubscriberService[newK]; ok {
		return fmt.Errorf("key %v already exists in SubscriberService", newK)
	}

	e, ok := t.SubscriberService[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SubscriberService", oldK)
	}
	e.TemplateName = &newK

	t.SubscriberService[newK] = e
	delete(t.SubscriberService, oldK)
	return nil
}

// GetOrCreateSubscriberServiceMap returns the list (map) from Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) GetOrCreateSubscriberServiceMap() map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService {
	if t.SubscriberService == nil {
		t.SubscriberService = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService)
	}
	return t.SubscriberService
}

// GetOrCreateSubscriberService retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) GetOrCreateSubscriberService(TemplateName string) *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService {

	key := TemplateName

	if v, ok := t.SubscriberService[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSubscriberService(TemplateName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSubscriberService got unexpected error: %v", err))
	}
	return v
}

// GetSubscriberService retrieves the value with the specified key from
// the SubscriberService map field of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) GetSubscriberService(TemplateName string) *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService {

	if t == nil {
		return nil
	}

	key := TemplateName

	if lm, ok := t.SubscriberService[key]; ok {
		return lm
	}
	return nil
}

// AppendSubscriberService appends the supplied Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService struct to the
// list SubscriberService of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices. If the key value(s) specified in
// the supplied Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) AppendSubscriberService(v *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService) error {
	if v.TemplateName == nil {
		return fmt.Errorf("invalid nil key received for TemplateName")
	}

	key := *v.TemplateName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SubscriberService == nil {
		t.SubscriberService = make(map[string]*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService)
	}

	if _, ok := t.SubscriberService[key]; ok {
		return fmt.Errorf("duplicate key for list SubscriberService %v", key)
	}

	t.SubscriberService[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices) ΛBelongingModule() string {
	return "Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"
}

// Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService represents the /Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg/dynamic-template/subscriber-services/subscriber-service YANG schema element.
type Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService struct {
	TemplateName *string `path:"template-name" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService struct, which is a YANG list entry.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService) ΛListKeyMap() (map[string]interface{}, error) {
	if t.TemplateName == nil {
		return nil, fmt.Errorf("nil value for key TemplateName")
	}

	return map[string]interface{}{
		"template-name": *t.TemplateName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService.
func (*Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate_SubscriberServices_SubscriberService) ΛBelongingModule() string {
	return "Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"
}
