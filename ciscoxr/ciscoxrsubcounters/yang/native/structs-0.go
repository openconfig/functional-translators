/*
Package native is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /usr/local/google/home/singhavnish/go/pkg/mod/github.com/openconfig/ygot@v0.33.0/genutil/names.go
using the following YANG input files:
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ifmgr-cfg.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-infra-statsd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-infra-statsd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ip-iarm-datatypes.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub3.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-types.yang
  - yang/vendor/cisco/xr/2431/cisco-semver.yang
  - yang/vendor/cisco/xr/2431/ietf-inet-types.yang

Imported modules were sourced from:
  - yang/vendor/cisco/xr/2431/...
*/
package native

import (
	"encoding/json"
	"fmt"
	"reflect"

	"github.com/openconfig/goyang/pkg/yang"
	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Binary is a type that is used for fields that have a YANG type of
// binary. It is used such that binary fields can be distinguished from
// leaf-lists of uint8s (which are mapped to []uint8, equivalent to
// []byte in reflection).
type Binary []byte

// YANGEmpty is a type that is used for fields that have a YANG type of
// empty. It is used such that empty fields can be distinguished from boolean fields
// in the generated code.
type YANGEmpty bool

// UnionInt8 is an int8 type assignable to unions of which it is a subtype.
type UnionInt8 int8

// UnionInt16 is an int16 type assignable to unions of which it is a subtype.
type UnionInt16 int16

// UnionInt32 is an int32 type assignable to unions of which it is a subtype.
type UnionInt32 int32

// UnionInt64 is an int64 type assignable to unions of which it is a subtype.
type UnionInt64 int64

// UnionUint8 is a uint8 type assignable to unions of which it is a subtype.
type UnionUint8 uint8

// UnionUint16 is a uint16 type assignable to unions of which it is a subtype.
type UnionUint16 uint16

// UnionUint32 is a uint32 type assignable to unions of which it is a subtype.
type UnionUint32 uint32

// UnionUint64 is a uint64 type assignable to unions of which it is a subtype.
type UnionUint64 uint64

// UnionFloat64 is a float64 type assignable to unions of which it is a subtype.
type UnionFloat64 float64

// UnionString is a string type assignable to unions of which it is a subtype.
type UnionString string

// UnionBool is a bool type assignable to unions of which it is a subtype.
type UnionBool bool

// UnionUnsupported is an interface{} wrapper type for unsupported types. It is
// assignable to unions of which it is a subtype.
type UnionUnsupported struct {
	Value interface{}
}

var (
	SchemaTree map[string]*yang.Entry
	ΛEnumTypes map[string][]reflect.Type
)

func init() {
	var err error
	initΛEnumTypes()
	if SchemaTree, err = UnzipSchema(); err != nil {
		panic("schema error: " + err.Error())
	}
}

// Schema returns the details of the generated schema.
func Schema() (*ytypes.Schema, error) {
	uzp, err := UnzipSchema()
	if err != nil {
		return nil, fmt.Errorf("cannot unzip schema, %v", err)
	}

	return &ytypes.Schema{
		Root:       &CiscoDevice{},
		SchemaTree: uzp,
		Unmarshal:  Unmarshal,
	}, nil
}

// UnzipSchema unzips the zipped schema and returns a map of yang.Entry nodes,
// keyed by the name of the struct that the yang.Entry describes the schema for.
func UnzipSchema() (map[string]*yang.Entry, error) {
	var schemaTree map[string]*yang.Entry
	var err error
	if schemaTree, err = ygot.GzipToSchema(ySchema); err != nil {
		return nil, fmt.Errorf("could not unzip the schema; %v", err)
	}
	return schemaTree, nil
}

// Unmarshal unmarshals data, which must be RFC7951 JSON format, into
// destStruct, which must be non-nil and the correct GoStruct type. It returns
// an error if the destStruct is not found in the schema or the data cannot be
// unmarshaled. The supplied options (opts) are used to control the behaviour
// of the unmarshal function - for example, determining whether errors are
// thrown for unknown fields in the input JSON.
func Unmarshal(data []byte, destStruct ygot.GoStruct, opts ...ytypes.UnmarshalOpt) error {
	tn := reflect.TypeOf(destStruct).Elem().Name()
	schema, ok := SchemaTree[tn]
	if !ok {
		return fmt.Errorf("could not find schema for type %s", tn)
	}
	var jsonTree interface{}
	if err := json.Unmarshal([]byte(data), &jsonTree); err != nil {
		return err
	}
	return ytypes.Unmarshal(schema, destStruct, jsonTree, opts...)
}

// CiscoDevice represents the /CiscoDevice YANG schema element.
type CiscoDevice struct {
	Arp                          *Cisco_IOS_XRIpv4ArpOper_Arp                           `path:"arp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpGmp                       *Cisco_IOS_XRIpv4ArpOper_ArpGmp                        `path:"arp-gmp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicTemplate              *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate `path:"dynamic-template" module:"Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg"`
	GlobalInterfaceConfiguration *Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration     `path:"global-interface-configuration" module:"Cisco-IOS-XR-ifmgr-cfg"`
	InfraStatistics              *Cisco_IOS_XRInfraStatsdOper_InfraStatistics           `path:"infra-statistics" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InterfaceConfigurations      *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations          `path:"interface-configurations" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Ipv4Network                  *Cisco_IOS_XRIpv4IoOper_Ipv4Network                    `path:"ipv4-network" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Ipv6NodeDiscovery            *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery              `path:"ipv6-node-discovery" module:"Cisco-IOS-XR-ipv6-nd-oper"`
}

// IsYANGGoStruct ensures that CiscoDevice implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*CiscoDevice) IsYANGGoStruct() {}

// GetOrCreateArp retrieves the value of the Arp field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateArp() *Cisco_IOS_XRIpv4ArpOper_Arp {
	if t.Arp != nil {
		return t.Arp
	}
	t.Arp = &Cisco_IOS_XRIpv4ArpOper_Arp{}
	return t.Arp
}

// GetOrCreateArpGmp retrieves the value of the ArpGmp field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateArpGmp() *Cisco_IOS_XRIpv4ArpOper_ArpGmp {
	if t.ArpGmp != nil {
		return t.ArpGmp
	}
	t.ArpGmp = &Cisco_IOS_XRIpv4ArpOper_ArpGmp{}
	return t.ArpGmp
}

// GetOrCreateDynamicTemplate retrieves the value of the DynamicTemplate field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateDynamicTemplate() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate {
	if t.DynamicTemplate != nil {
		return t.DynamicTemplate
	}
	t.DynamicTemplate = &Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate{}
	return t.DynamicTemplate
}

// GetOrCreateGlobalInterfaceConfiguration retrieves the value of the GlobalInterfaceConfiguration field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateGlobalInterfaceConfiguration() *Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration {
	if t.GlobalInterfaceConfiguration != nil {
		return t.GlobalInterfaceConfiguration
	}
	t.GlobalInterfaceConfiguration = &Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration{}
	return t.GlobalInterfaceConfiguration
}

// GetOrCreateInfraStatistics retrieves the value of the InfraStatistics field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateInfraStatistics() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics {
	if t.InfraStatistics != nil {
		return t.InfraStatistics
	}
	t.InfraStatistics = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics{}
	return t.InfraStatistics
}

// GetOrCreateInterfaceConfigurations retrieves the value of the InterfaceConfigurations field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateInterfaceConfigurations() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations {
	if t.InterfaceConfigurations != nil {
		return t.InterfaceConfigurations
	}
	t.InterfaceConfigurations = &Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations{}
	return t.InterfaceConfigurations
}

// GetOrCreateIpv4Network retrieves the value of the Ipv4Network field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateIpv4Network() *Cisco_IOS_XRIpv4IoOper_Ipv4Network {
	if t.Ipv4Network != nil {
		return t.Ipv4Network
	}
	t.Ipv4Network = &Cisco_IOS_XRIpv4IoOper_Ipv4Network{}
	return t.Ipv4Network
}

// GetOrCreateIpv6NodeDiscovery retrieves the value of the Ipv6NodeDiscovery field
// or returns the existing field if it already exists.
func (t *CiscoDevice) GetOrCreateIpv6NodeDiscovery() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery {
	if t.Ipv6NodeDiscovery != nil {
		return t.Ipv6NodeDiscovery
	}
	t.Ipv6NodeDiscovery = &Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery{}
	return t.Ipv6NodeDiscovery
}

// GetArp returns the value of the Arp struct pointer
// from CiscoDevice. If the receiver or the field Arp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetArp() *Cisco_IOS_XRIpv4ArpOper_Arp {
	if t != nil && t.Arp != nil {
		return t.Arp
	}
	return nil
}

// GetArpGmp returns the value of the ArpGmp struct pointer
// from CiscoDevice. If the receiver or the field ArpGmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetArpGmp() *Cisco_IOS_XRIpv4ArpOper_ArpGmp {
	if t != nil && t.ArpGmp != nil {
		return t.ArpGmp
	}
	return nil
}

// GetDynamicTemplate returns the value of the DynamicTemplate struct pointer
// from CiscoDevice. If the receiver or the field DynamicTemplate is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetDynamicTemplate() *Cisco_IOS_XRSubscriberInfraTmplmgrCfg_DynamicTemplate {
	if t != nil && t.DynamicTemplate != nil {
		return t.DynamicTemplate
	}
	return nil
}

// GetGlobalInterfaceConfiguration returns the value of the GlobalInterfaceConfiguration struct pointer
// from CiscoDevice. If the receiver or the field GlobalInterfaceConfiguration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetGlobalInterfaceConfiguration() *Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration {
	if t != nil && t.GlobalInterfaceConfiguration != nil {
		return t.GlobalInterfaceConfiguration
	}
	return nil
}

// GetInfraStatistics returns the value of the InfraStatistics struct pointer
// from CiscoDevice. If the receiver or the field InfraStatistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetInfraStatistics() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics {
	if t != nil && t.InfraStatistics != nil {
		return t.InfraStatistics
	}
	return nil
}

// GetInterfaceConfigurations returns the value of the InterfaceConfigurations struct pointer
// from CiscoDevice. If the receiver or the field InterfaceConfigurations is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetInterfaceConfigurations() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations {
	if t != nil && t.InterfaceConfigurations != nil {
		return t.InterfaceConfigurations
	}
	return nil
}

// GetIpv4Network returns the value of the Ipv4Network struct pointer
// from CiscoDevice. If the receiver or the field Ipv4Network is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetIpv4Network() *Cisco_IOS_XRIpv4IoOper_Ipv4Network {
	if t != nil && t.Ipv4Network != nil {
		return t.Ipv4Network
	}
	return nil
}

// GetIpv6NodeDiscovery returns the value of the Ipv6NodeDiscovery struct pointer
// from CiscoDevice. If the receiver or the field Ipv6NodeDiscovery is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *CiscoDevice) GetIpv6NodeDiscovery() *Cisco_IOS_XRIpv6NdOper_Ipv6NodeDiscovery {
	if t != nil && t.Ipv6NodeDiscovery != nil {
		return t.Ipv6NodeDiscovery
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *CiscoDevice) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["CiscoDevice"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *CiscoDevice) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *CiscoDevice) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of CiscoDevice.
func (*CiscoDevice) ΛBelongingModule() string {
	return ""
}

// Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration represents the /Cisco-IOS-XR-ifmgr-cfg/global-interface-configuration YANG schema element.
type Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration struct {
	LinkStatus E_Cisco_IOS_XRIfmgrCfg_LinkStatusEnum `path:"link-status" module:"Cisco-IOS-XR-ifmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration.
func (*Cisco_IOS_XRIfmgrCfg_GlobalInterfaceConfiguration) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ifmgr-cfg"
}

// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations represents the /Cisco-IOS-XR-ifmgr-cfg/interface-configurations YANG schema element.
type Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations struct {
	InterfaceConfiguration map[Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration `path:"interface-configuration" module:"Cisco-IOS-XR-ifmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) IsYANGGoStruct() {}

// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key represents the key for list InterfaceConfiguration of element /Cisco-IOS-XR-ifmgr-cfg/interface-configurations.
type Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key struct {
	Active        string `path:"active"`
	InterfaceName string `path:"interface-name"`
}

// IsYANGGoKeyStruct ensures that Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key key struct.
func (t Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"active":         t.Active,
		"interface-name": t.InterfaceName,
	}, nil
}

// NewInterfaceConfiguration creates a new entry in the InterfaceConfiguration list of the
// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) NewInterfaceConfiguration(Active string, InterfaceName string) (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterfaceConfiguration == nil {
		t.InterfaceConfiguration = make(map[Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration)
	}

	key := Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key{
		Active:        Active,
		InterfaceName: InterfaceName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InterfaceConfiguration[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InterfaceConfiguration", key)
	}

	t.InterfaceConfiguration[key] = &Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration{
		Active:        &Active,
		InterfaceName: &InterfaceName,
	}

	return t.InterfaceConfiguration[key], nil
}

// RenameInterfaceConfiguration renames an entry in the list InterfaceConfiguration within
// the Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) RenameInterfaceConfiguration(oldK, newK Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key) error {
	if _, ok := t.InterfaceConfiguration[newK]; ok {
		return fmt.Errorf("key %v already exists in InterfaceConfiguration", newK)
	}

	e, ok := t.InterfaceConfiguration[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InterfaceConfiguration", oldK)
	}
	e.Active = &newK.Active
	e.InterfaceName = &newK.InterfaceName

	t.InterfaceConfiguration[newK] = e
	delete(t.InterfaceConfiguration, oldK)
	return nil
}

// GetOrCreateInterfaceConfigurationMap returns the list (map) from Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) GetOrCreateInterfaceConfigurationMap() map[Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration {
	if t.InterfaceConfiguration == nil {
		t.InterfaceConfiguration = make(map[Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration)
	}
	return t.InterfaceConfiguration
}

// GetOrCreateInterfaceConfiguration retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) GetOrCreateInterfaceConfiguration(Active string, InterfaceName string) *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration {

	key := Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key{
		Active:        Active,
		InterfaceName: InterfaceName,
	}

	if v, ok := t.InterfaceConfiguration[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterfaceConfiguration(Active, InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterfaceConfiguration got unexpected error: %v", err))
	}
	return v
}

// GetInterfaceConfiguration retrieves the value with the specified key from
// the InterfaceConfiguration map field of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) GetInterfaceConfiguration(Active string, InterfaceName string) *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration {

	if t == nil {
		return nil
	}

	key := Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key{
		Active:        Active,
		InterfaceName: InterfaceName,
	}

	if lm, ok := t.InterfaceConfiguration[key]; ok {
		return lm
	}
	return nil
}

// AppendInterfaceConfiguration appends the supplied Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration struct to the
// list InterfaceConfiguration of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations. If the key value(s) specified in
// the supplied Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) AppendInterfaceConfiguration(v *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) error {
	if v.Active == nil {
		return fmt.Errorf("invalid nil key for Active")
	}

	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key for InterfaceName")
	}

	key := Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key{
		Active:        *v.Active,
		InterfaceName: *v.InterfaceName,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterfaceConfiguration == nil {
		t.InterfaceConfiguration = make(map[Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Key]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration)
	}

	if _, ok := t.InterfaceConfiguration[key]; ok {
		return fmt.Errorf("duplicate key for list InterfaceConfiguration %v", key)
	}

	t.InterfaceConfiguration[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ifmgr-cfg"
}

// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration represents the /Cisco-IOS-XR-ifmgr-cfg/interface-configurations/interface-configuration YANG schema element.
type Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration struct {
	Active                   *string                                                                            `path:"active" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Bandwidth                *uint64                                                                            `path:"bandwidth" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Dampening                *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening     `path:"dampening" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Description              *string                                                                            `path:"description" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Encapsulation            *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation `path:"encapsulation" module:"Cisco-IOS-XR-ifmgr-cfg"`
	InterfaceModeNonPhysical E_Cisco_IOS_XRIfmgrCfg_InterfaceModeEnum                                           `path:"interface-mode-non-physical" module:"Cisco-IOS-XR-ifmgr-cfg"`
	InterfaceName            *string                                                                            `path:"interface-name" module:"Cisco-IOS-XR-ifmgr-cfg"`
	InterfaceVirtual         YANGEmpty                                                                          `path:"interface-virtual" module:"Cisco-IOS-XR-ifmgr-cfg"`
	LinkStatus               YANGEmpty                                                                          `path:"link-status" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Mtus                     *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus          `path:"mtus" module:"Cisco-IOS-XR-ifmgr-cfg"`
	SecondaryAdminState      E_Cisco_IOS_XRIfmgrCfg_SecondaryAdminStateEnum                                     `path:"secondary-admin-state" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Shutdown                 YANGEmpty                                                                          `path:"shutdown" module:"Cisco-IOS-XR-ifmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) IsYANGGoStruct() {}

// GetOrCreateDampening retrieves the value of the Dampening field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) GetOrCreateDampening() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening {
	if t.Dampening != nil {
		return t.Dampening
	}
	t.Dampening = &Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening{}
	return t.Dampening
}

// GetOrCreateEncapsulation retrieves the value of the Encapsulation field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) GetOrCreateEncapsulation() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation {
	if t.Encapsulation != nil {
		return t.Encapsulation
	}
	t.Encapsulation = &Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation{}
	return t.Encapsulation
}

// GetOrCreateMtus retrieves the value of the Mtus field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) GetOrCreateMtus() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus {
	if t.Mtus != nil {
		return t.Mtus
	}
	t.Mtus = &Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus{}
	return t.Mtus
}

// GetDampening returns the value of the Dampening struct pointer
// from Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration. If the receiver or the field Dampening is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) GetDampening() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening {
	if t != nil && t.Dampening != nil {
		return t.Dampening
	}
	return nil
}

// GetEncapsulation returns the value of the Encapsulation struct pointer
// from Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration. If the receiver or the field Encapsulation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) GetEncapsulation() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation {
	if t != nil && t.Encapsulation != nil {
		return t.Encapsulation
	}
	return nil
}

// GetMtus returns the value of the Mtus struct pointer
// from Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration. If the receiver or the field Mtus is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) GetMtus() *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus {
	if t != nil && t.Mtus != nil {
		return t.Mtus
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Active == nil {
		return nil, fmt.Errorf("nil value for key Active")
	}

	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"active":         *t.Active,
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ifmgr-cfg"
}

// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening represents the /Cisco-IOS-XR-ifmgr-cfg/interface-configurations/interface-configuration/dampening YANG schema element.
type Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening struct {
	Args              E_Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening_Args `path:"args" module:"Cisco-IOS-XR-ifmgr-cfg"`
	HalfLife          *uint32                                                                              `path:"half-life" module:"Cisco-IOS-XR-ifmgr-cfg"`
	RestartPenalty    *uint32                                                                              `path:"restart-penalty" module:"Cisco-IOS-XR-ifmgr-cfg"`
	ReuseThreshold    *uint32                                                                              `path:"reuse-threshold" module:"Cisco-IOS-XR-ifmgr-cfg"`
	SuppressThreshold *uint32                                                                              `path:"suppress-threshold" module:"Cisco-IOS-XR-ifmgr-cfg"`
	SuppressTime      *uint32                                                                              `path:"suppress-time" module:"Cisco-IOS-XR-ifmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Dampening) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ifmgr-cfg"
}

// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation represents the /Cisco-IOS-XR-ifmgr-cfg/interface-configurations/interface-configuration/encapsulation YANG schema element.
type Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation struct {
	CapsulationOptions *uint32 `path:"capsulation-options" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Encapsulation      *string `path:"encapsulation" module:"Cisco-IOS-XR-ifmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Encapsulation) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ifmgr-cfg"
}

// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus represents the /Cisco-IOS-XR-ifmgr-cfg/interface-configurations/interface-configuration/mtus YANG schema element.
type Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus struct {
	Mtu map[string]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu `path:"mtu" module:"Cisco-IOS-XR-ifmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) IsYANGGoStruct() {}

// NewMtu creates a new entry in the Mtu list of the
// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) NewMtu(Owner string) (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mtu == nil {
		t.Mtu = make(map[string]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu)
	}

	key := Owner

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mtu[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mtu", key)
	}

	t.Mtu[key] = &Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu{
		Owner: &Owner,
	}

	return t.Mtu[key], nil
}

// RenameMtu renames an entry in the list Mtu within
// the Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) RenameMtu(oldK, newK string) error {
	if _, ok := t.Mtu[newK]; ok {
		return fmt.Errorf("key %v already exists in Mtu", newK)
	}

	e, ok := t.Mtu[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mtu", oldK)
	}
	e.Owner = &newK

	t.Mtu[newK] = e
	delete(t.Mtu, oldK)
	return nil
}

// GetOrCreateMtuMap returns the list (map) from Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) GetOrCreateMtuMap() map[string]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu {
	if t.Mtu == nil {
		t.Mtu = make(map[string]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu)
	}
	return t.Mtu
}

// GetOrCreateMtu retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) GetOrCreateMtu(Owner string) *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu {

	key := Owner

	if v, ok := t.Mtu[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMtu(Owner)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMtu got unexpected error: %v", err))
	}
	return v
}

// GetMtu retrieves the value with the specified key from
// the Mtu map field of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) GetMtu(Owner string) *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu {

	if t == nil {
		return nil
	}

	key := Owner

	if lm, ok := t.Mtu[key]; ok {
		return lm
	}
	return nil
}

// AppendMtu appends the supplied Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu struct to the
// list Mtu of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus. If the key value(s) specified in
// the supplied Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) AppendMtu(v *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu) error {
	if v.Owner == nil {
		return fmt.Errorf("invalid nil key received for Owner")
	}

	key := *v.Owner

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mtu == nil {
		t.Mtu = make(map[string]*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu)
	}

	if _, ok := t.Mtu[key]; ok {
		return fmt.Errorf("duplicate key for list Mtu %v", key)
	}

	t.Mtu[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ifmgr-cfg"
}

// Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu represents the /Cisco-IOS-XR-ifmgr-cfg/interface-configurations/interface-configuration/mtus/mtu YANG schema element.
type Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu struct {
	Mtu   *uint32 `path:"mtu" module:"Cisco-IOS-XR-ifmgr-cfg"`
	Owner *string `path:"owner" module:"Cisco-IOS-XR-ifmgr-cfg"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Owner == nil {
		return nil, fmt.Errorf("nil value for key Owner")
	}

	return map[string]interface{}{
		"owner": *t.Owner,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu.
func (*Cisco_IOS_XRIfmgrCfg_InterfaceConfigurations_InterfaceConfiguration_Mtus_Mtu) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ifmgr-cfg"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics struct {
	CounterRates *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates `path:"counter-rates" module:"Cisco-IOS-XR-infra-statsd-oper"`
	Interfaces   *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces   `path:"interfaces" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics) IsYANGGoStruct() {}

// GetOrCreateCounterRates retrieves the value of the CounterRates field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics) GetOrCreateCounterRates() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates {
	if t.CounterRates != nil {
		return t.CounterRates
	}
	t.CounterRates = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates{}
	return t.CounterRates
}

// GetOrCreateInterfaces retrieves the value of the Interfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics) GetOrCreateInterfaces() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces {
	if t.Interfaces != nil {
		return t.Interfaces
	}
	t.Interfaces = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces{}
	return t.Interfaces
}

// GetCounterRates returns the value of the CounterRates struct pointer
// from Cisco_IOS_XRInfraStatsdOper_InfraStatistics. If the receiver or the field CounterRates is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics) GetCounterRates() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates {
	if t != nil && t.CounterRates != nil {
		return t.CounterRates
	}
	return nil
}

// GetInterfaces returns the value of the Interfaces struct pointer
// from Cisco_IOS_XRInfraStatsdOper_InfraStatistics. If the receiver or the field Interfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics) GetInterfaces() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces {
	if t != nil && t.Interfaces != nil {
		return t.Interfaces
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/counter-rates YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates struct {
	InterfaceRates *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates `path:"interface-rates" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates) IsYANGGoStruct() {}

// GetOrCreateInterfaceRates retrieves the value of the InterfaceRates field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates) GetOrCreateInterfaceRates() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates {
	if t.InterfaceRates != nil {
		return t.InterfaceRates
	}
	t.InterfaceRates = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates{}
	return t.InterfaceRates
}

// GetInterfaceRates returns the value of the InterfaceRates struct pointer
// from Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates. If the receiver or the field InterfaceRates is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates) GetInterfaceRates() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates {
	if t != nil && t.InterfaceRates != nil {
		return t.InterfaceRates
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/counter-rates/interface-rates YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates struct {
	InterfaceRate map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate `path:"interface-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) IsYANGGoStruct() {}

// NewInterfaceRate creates a new entry in the InterfaceRate list of the
// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) NewInterfaceRate(InterfaceName string) (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterfaceRate == nil {
		t.InterfaceRate = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.InterfaceRate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list InterfaceRate", key)
	}

	t.InterfaceRate[key] = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate{
		InterfaceName: &InterfaceName,
	}

	return t.InterfaceRate[key], nil
}

// RenameInterfaceRate renames an entry in the list InterfaceRate within
// the Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) RenameInterfaceRate(oldK, newK string) error {
	if _, ok := t.InterfaceRate[newK]; ok {
		return fmt.Errorf("key %v already exists in InterfaceRate", newK)
	}

	e, ok := t.InterfaceRate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in InterfaceRate", oldK)
	}
	e.InterfaceName = &newK

	t.InterfaceRate[newK] = e
	delete(t.InterfaceRate, oldK)
	return nil
}

// GetOrCreateInterfaceRateMap returns the list (map) from Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) GetOrCreateInterfaceRateMap() map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate {
	if t.InterfaceRate == nil {
		t.InterfaceRate = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate)
	}
	return t.InterfaceRate
}

// GetOrCreateInterfaceRate retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) GetOrCreateInterfaceRate(InterfaceName string) *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate {

	key := InterfaceName

	if v, ok := t.InterfaceRate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterfaceRate(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterfaceRate got unexpected error: %v", err))
	}
	return v
}

// GetInterfaceRate retrieves the value with the specified key from
// the InterfaceRate map field of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) GetInterfaceRate(InterfaceName string) *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.InterfaceRate[key]; ok {
		return lm
	}
	return nil
}

// AppendInterfaceRate appends the supplied Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate struct to the
// list InterfaceRate of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates. If the key value(s) specified in
// the supplied Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) AppendInterfaceRate(v *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.InterfaceRate == nil {
		t.InterfaceRate = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate)
	}

	if _, ok := t.InterfaceRate[key]; ok {
		return fmt.Errorf("duplicate key for list InterfaceRate %v", key)
	}

	t.InterfaceRate[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/counter-rates/interface-rates/interface-rate YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate struct {
	BandwidthKbps          *uint64 `path:"bandwidth-kbps" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputBandwidthPercent  *uint8  `path:"input-bandwidth-percent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputDatarateKbps      *uint64 `path:"input-datarate-kbps" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputPacketratepps     *uint64 `path:"input-packetratepps" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InterfaceName          *string `path:"interface-name" module:"Cisco-IOS-XR-infra-statsd-oper"`
	LastUpdateTime         *uint64 `path:"last-update-time" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputBandwidthPercent *uint8  `path:"output-bandwidth-percent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputDatarateKbps     *uint64 `path:"output-datarate-kbps" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputPacketratepps    *uint64 `path:"output-packetratepps" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OverheadBytes          *uint64 `path:"overhead-bytes" module:"Cisco-IOS-XR-infra-statsd-oper"`
	TimeIntervalMs         *uint64 `path:"time-interval-ms" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate struct, which is a YANG list entry.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_CounterRates_InterfaceRates_InterfaceRate) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/interfaces YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces struct {
	Interface map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface `path:"interface" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) NewInterface(InterfaceName string) (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface{
		InterfaceName: &InterfaceName,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceName = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) GetOrCreateInterfaceMap() map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) GetOrCreateInterface(InterfaceName string) *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface {

	key := InterfaceName

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) GetInterface(InterfaceName string) *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface struct to the
// list Interface of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) AppendInterface(v *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/interfaces/interface YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface struct {
	DataRate        *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate        `path:"data-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	GenericCounters *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters `path:"generic-counters" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InterfaceName   *string                                                                           `path:"interface-name" module:"Cisco-IOS-XR-infra-statsd-oper"`
	Protocols       *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols       `path:"protocols" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) IsYANGGoStruct() {}

// GetOrCreateDataRate retrieves the value of the DataRate field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) GetOrCreateDataRate() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate {
	if t.DataRate != nil {
		return t.DataRate
	}
	t.DataRate = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate{}
	return t.DataRate
}

// GetOrCreateGenericCounters retrieves the value of the GenericCounters field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) GetOrCreateGenericCounters() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters {
	if t.GenericCounters != nil {
		return t.GenericCounters
	}
	t.GenericCounters = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters{}
	return t.GenericCounters
}

// GetOrCreateProtocols retrieves the value of the Protocols field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) GetOrCreateProtocols() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols {
	if t.Protocols != nil {
		return t.Protocols
	}
	t.Protocols = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols{}
	return t.Protocols
}

// GetDataRate returns the value of the DataRate struct pointer
// from Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface. If the receiver or the field DataRate is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) GetDataRate() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate {
	if t != nil && t.DataRate != nil {
		return t.DataRate
	}
	return nil
}

// GetGenericCounters returns the value of the GenericCounters struct pointer
// from Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface. If the receiver or the field GenericCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) GetGenericCounters() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters {
	if t != nil && t.GenericCounters != nil {
		return t.GenericCounters
	}
	return nil
}

// GetProtocols returns the value of the Protocols struct pointer
// from Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface. If the receiver or the field Protocols is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) GetProtocols() *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols {
	if t != nil && t.Protocols != nil {
		return t.Protocols
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/interfaces/interface/data-rate YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate struct {
	Bandwidth            *uint64 `path:"bandwidth" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputDataRate        *uint64 `path:"input-data-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputLoad            *uint8  `path:"input-load" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputPacketRate      *uint64 `path:"input-packet-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	LoadInterval         *uint32 `path:"load-interval" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputDataRate       *uint64 `path:"output-data-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputLoad           *uint8  `path:"output-load" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputPacketRate     *uint64 `path:"output-packet-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PeakInputDataRate    *uint64 `path:"peak-input-data-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PeakInputPacketRate  *uint64 `path:"peak-input-packet-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PeakOutputDataRate   *uint64 `path:"peak-output-data-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PeakOutputPacketRate *uint64 `path:"peak-output-packet-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	Reliability          *uint8  `path:"reliability" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_DataRate) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/interfaces/interface/generic-counters YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters struct {
	Applique                       *uint32 `path:"applique" module:"Cisco-IOS-XR-infra-statsd-oper"`
	AvailabilityFlag               *uint32 `path:"availability-flag" module:"Cisco-IOS-XR-infra-statsd-oper"`
	BroadcastPacketsReceived       *uint64 `path:"broadcast-packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	BroadcastPacketsSent           *uint64 `path:"broadcast-packets-sent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	BytesReceived                  *uint64 `path:"bytes-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	BytesSent                      *uint64 `path:"bytes-sent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	CarrierTransitions             *uint32 `path:"carrier-transitions" module:"Cisco-IOS-XR-infra-statsd-oper"`
	CrcErrors                      *uint32 `path:"crc-errors" module:"Cisco-IOS-XR-infra-statsd-oper"`
	FramingErrorsReceived          *uint32 `path:"framing-errors-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	GiantPacketsReceived           *uint32 `path:"giant-packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	HardwareTimestamp              *uint64 `path:"hardware-timestamp" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputAborts                    *uint32 `path:"input-aborts" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputDrops                     *uint32 `path:"input-drops" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputErrors                    *uint32 `path:"input-errors" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputIgnoredPackets            *uint32 `path:"input-ignored-packets" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputOverruns                  *uint32 `path:"input-overruns" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputQueueDrops                *uint32 `path:"input-queue-drops" module:"Cisco-IOS-XR-infra-statsd-oper"`
	LastDataTime                   *uint64 `path:"last-data-time" module:"Cisco-IOS-XR-infra-statsd-oper"`
	LastDiscontinuityTime          *uint32 `path:"last-discontinuity-time" module:"Cisco-IOS-XR-infra-statsd-oper"`
	MulticastPacketsReceived       *uint64 `path:"multicast-packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	MulticastPacketsSent           *uint64 `path:"multicast-packets-sent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputBufferFailures           *uint32 `path:"output-buffer-failures" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputBuffersSwappedOut        *uint32 `path:"output-buffers-swapped-out" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputDrops                    *uint32 `path:"output-drops" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputErrors                   *uint32 `path:"output-errors" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputQueueDrops               *uint32 `path:"output-queue-drops" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputUnderruns                *uint32 `path:"output-underruns" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PacketsReceived                *uint64 `path:"packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PacketsSent                    *uint64 `path:"packets-sent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	ParityPacketsReceived          *uint32 `path:"parity-packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	Resets                         *uint32 `path:"resets" module:"Cisco-IOS-XR-infra-statsd-oper"`
	RuntPacketsReceived            *uint32 `path:"runt-packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	SecondsSinceLastClearCounters  *uint32 `path:"seconds-since-last-clear-counters" module:"Cisco-IOS-XR-infra-statsd-oper"`
	SecondsSincePacketReceived     *uint32 `path:"seconds-since-packet-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	SecondsSincePacketSent         *uint32 `path:"seconds-since-packet-sent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	ThrottledPacketsReceived       *uint32 `path:"throttled-packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	UnknownProtocolPacketsReceived *uint32 `path:"unknown-protocol-packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_GenericCounters) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/interfaces/interface/protocols YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols struct {
	Protocol map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol `path:"protocol" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) IsYANGGoStruct() {}

// NewProtocol creates a new entry in the Protocol list of the
// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) NewProtocol(ProtocolName string) (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol)
	}

	key := ProtocolName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol{
		ProtocolName: &ProtocolName,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) RenameProtocol(oldK, newK string) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.ProtocolName = &newK

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocolMap returns the list (map) from Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) GetOrCreateProtocolMap() map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol {
	if t.Protocol == nil {
		t.Protocol = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol)
	}
	return t.Protocol
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) GetOrCreateProtocol(ProtocolName string) *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol {

	key := ProtocolName

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(ProtocolName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) GetProtocol(ProtocolName string) *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol {

	if t == nil {
		return nil
	}

	key := ProtocolName

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// AppendProtocol appends the supplied Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol struct to the
// list Protocol of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols. If the key value(s) specified in
// the supplied Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) AppendProtocol(v *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol) error {
	if v.ProtocolName == nil {
		return fmt.Errorf("invalid nil key received for ProtocolName")
	}

	key := *v.ProtocolName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[string]*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol represents the /Cisco-IOS-XR-infra-statsd-oper/infra-statistics/interfaces/interface/protocols/protocol YANG schema element.
type Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol struct {
	BytesReceived     *uint64 `path:"bytes-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	BytesSent         *uint64 `path:"bytes-sent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	HardwareTimestamp *uint64 `path:"hardware-timestamp" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputDataRate     *uint64 `path:"input-data-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	InputPacketRate   *uint64 `path:"input-packet-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	LastDataTime      *uint64 `path:"last-data-time" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputDataRate    *uint64 `path:"output-data-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	OutputPacketRate  *uint64 `path:"output-packet-rate" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PacketsReceived   *uint64 `path:"packets-received" module:"Cisco-IOS-XR-infra-statsd-oper"`
	PacketsSent       *uint64 `path:"packets-sent" module:"Cisco-IOS-XR-infra-statsd-oper"`
	Protocol          *uint32 `path:"protocol" module:"Cisco-IOS-XR-infra-statsd-oper"`
	ProtocolName      *string `path:"protocol-name" module:"Cisco-IOS-XR-infra-statsd-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol struct, which is a YANG list entry.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ProtocolName == nil {
		return nil, fmt.Errorf("nil value for key ProtocolName")
	}

	return map[string]interface{}{
		"protocol-name": *t.ProtocolName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol.
func (*Cisco_IOS_XRInfraStatsdOper_InfraStatistics_Interfaces_Interface_Protocols_Protocol) ΛBelongingModule() string {
	return "Cisco-IOS-XR-infra-statsd-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp represents the /Cisco-IOS-XR-ipv4-arp-oper/arp YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp struct {
	Nodes *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes `path:"nodes" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp) IsYANGGoStruct() {}

// GetOrCreateNodes retrieves the value of the Nodes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) GetOrCreateNodes() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes {
	if t.Nodes != nil {
		return t.Nodes
	}
	t.Nodes = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes{}
	return t.Nodes
}

// GetNodes returns the value of the Nodes struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp. If the receiver or the field Nodes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) GetNodes() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes {
	if t != nil && t.Nodes != nil {
		return t.Nodes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp) ΛEnumTypeMap() map[string][]reflect.Type { return ΛEnumTypes }

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp.
func (*Cisco_IOS_XRIpv4ArpOper_Arp) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp struct {
	VrfInfos *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos `path:"vrf-infos" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Vrfs     *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs     `path:"vrfs" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp) IsYANGGoStruct() {}

// GetOrCreateVrfInfos retrieves the value of the VrfInfos field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetOrCreateVrfInfos() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos {
	if t.VrfInfos != nil {
		return t.VrfInfos
	}
	t.VrfInfos = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos{}
	return t.VrfInfos
}

// GetOrCreateVrfs retrieves the value of the Vrfs field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetOrCreateVrfs() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs {
	if t.Vrfs != nil {
		return t.Vrfs
	}
	t.Vrfs = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs{}
	return t.Vrfs
}

// GetVrfInfos returns the value of the VrfInfos struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp. If the receiver or the field VrfInfos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetVrfInfos() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos {
	if t != nil && t.VrfInfos != nil {
		return t.VrfInfos
	}
	return nil
}

// GetVrfs returns the value of the Vrfs struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp. If the receiver or the field Vrfs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) GetVrfs() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs {
	if t != nil && t.Vrfs != nil {
		return t.Vrfs
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrf-infos YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos struct {
	VrfInfo map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo `path:"vrf-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) IsYANGGoStruct() {}

// NewVrfInfo creates a new entry in the VrfInfo list of the
// Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) NewVrfInfo(VrfName string) (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrfInfo == nil {
		t.VrfInfo = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrfInfo[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrfInfo", key)
	}

	t.VrfInfo[key] = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo{
		VrfName: &VrfName,
	}

	return t.VrfInfo[key], nil
}

// RenameVrfInfo renames an entry in the list VrfInfo within
// the Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) RenameVrfInfo(oldK, newK string) error {
	if _, ok := t.VrfInfo[newK]; ok {
		return fmt.Errorf("key %v already exists in VrfInfo", newK)
	}

	e, ok := t.VrfInfo[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrfInfo", oldK)
	}
	e.VrfName = &newK

	t.VrfInfo[newK] = e
	delete(t.VrfInfo, oldK)
	return nil
}

// GetOrCreateVrfInfoMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) GetOrCreateVrfInfoMap() map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo {
	if t.VrfInfo == nil {
		t.VrfInfo = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo)
	}
	return t.VrfInfo
}

// GetOrCreateVrfInfo retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) GetOrCreateVrfInfo(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo {

	key := VrfName

	if v, ok := t.VrfInfo[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrfInfo(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrfInfo got unexpected error: %v", err))
	}
	return v
}

// GetVrfInfo retrieves the value with the specified key from
// the VrfInfo map field of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) GetVrfInfo(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.VrfInfo[key]; ok {
		return lm
	}
	return nil
}

// AppendVrfInfo appends the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo struct to the
// list VrfInfo of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) AppendVrfInfo(v *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrfInfo == nil {
		t.VrfInfo = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo)
	}

	if _, ok := t.VrfInfo[key]; ok {
		return fmt.Errorf("duplicate key for list VrfInfo %v", key)
	}

	t.VrfInfo[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrf-infos/vrf-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo struct {
	RsiHandle     *uint32 `path:"rsi-handle" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RsiHandleHigh *uint32 `path:"rsi-handle-high" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TableId       *uint32 `path:"table-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfIdNumber   *uint32 `path:"vrf-id-number" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName       *string `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfNameXr     *string `path:"vrf-name-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_VrfInfos_VrfInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs struct {
	Vrf map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf `path:"vrf" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) IsYANGGoStruct() {}

// NewVrf creates a new entry in the Vrf list of the
// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) NewVrf(VrfName string) (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vrf[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vrf", key)
	}

	t.Vrf[key] = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf{
		VrfName: &VrfName,
	}

	return t.Vrf[key], nil
}

// RenameVrf renames an entry in the list Vrf within
// the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) RenameVrf(oldK, newK string) error {
	if _, ok := t.Vrf[newK]; ok {
		return fmt.Errorf("key %v already exists in Vrf", newK)
	}

	e, ok := t.Vrf[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vrf", oldK)
	}
	e.VrfName = &newK

	t.Vrf[newK] = e
	delete(t.Vrf, oldK)
	return nil
}

// GetOrCreateVrfMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) GetOrCreateVrfMap() map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf {
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf)
	}
	return t.Vrf
}

// GetOrCreateVrf retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) GetOrCreateVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf {

	key := VrfName

	if v, ok := t.Vrf[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrf(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrf got unexpected error: %v", err))
	}
	return v
}

// GetVrf retrieves the value with the specified key from
// the Vrf map field of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) GetVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.Vrf[key]; ok {
		return lm
	}
	return nil
}

// AppendVrf appends the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf struct to the
// list Vrf of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) AppendVrf(v *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf)
	}

	if _, ok := t.Vrf[key]; ok {
		return fmt.Errorf("duplicate key for list Vrf %v", key)
	}

	t.Vrf[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf struct {
	ConfiguredIpAddresses          *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses          `path:"configured-ip-addresses" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceConfiguredIpAddresses *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses `path:"interface-configured-ip-addresses" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Routes                         *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes                         `path:"routes" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName                        *string                                                                 `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) IsYANGGoStruct() {}

// GetOrCreateConfiguredIpAddresses retrieves the value of the ConfiguredIpAddresses field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetOrCreateConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses {
	if t.ConfiguredIpAddresses != nil {
		return t.ConfiguredIpAddresses
	}
	t.ConfiguredIpAddresses = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses{}
	return t.ConfiguredIpAddresses
}

// GetOrCreateInterfaceConfiguredIpAddresses retrieves the value of the InterfaceConfiguredIpAddresses field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetOrCreateInterfaceConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses {
	if t.InterfaceConfiguredIpAddresses != nil {
		return t.InterfaceConfiguredIpAddresses
	}
	t.InterfaceConfiguredIpAddresses = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses{}
	return t.InterfaceConfiguredIpAddresses
}

// GetOrCreateRoutes retrieves the value of the Routes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetOrCreateRoutes() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes {
	if t.Routes != nil {
		return t.Routes
	}
	t.Routes = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes{}
	return t.Routes
}

// GetConfiguredIpAddresses returns the value of the ConfiguredIpAddresses struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf. If the receiver or the field ConfiguredIpAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses {
	if t != nil && t.ConfiguredIpAddresses != nil {
		return t.ConfiguredIpAddresses
	}
	return nil
}

// GetInterfaceConfiguredIpAddresses returns the value of the InterfaceConfiguredIpAddresses struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf. If the receiver or the field InterfaceConfiguredIpAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetInterfaceConfiguredIpAddresses() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses {
	if t != nil && t.InterfaceConfiguredIpAddresses != nil {
		return t.InterfaceConfiguredIpAddresses
	}
	return nil
}

// GetRoutes returns the value of the Routes struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf. If the receiver or the field Routes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) GetRoutes() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes {
	if t != nil && t.Routes != nil {
		return t.Routes
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/configured-ip-addresses YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses struct {
	ConfiguredIpAddress map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress `path:"configured-ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) IsYANGGoStruct() {}

// NewConfiguredIpAddress creates a new entry in the ConfiguredIpAddress list of the
// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) NewConfiguredIpAddress(Address string) (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConfiguredIpAddress == nil {
		t.ConfiguredIpAddress = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress)
	}

	key := Address

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ConfiguredIpAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ConfiguredIpAddress", key)
	}

	t.ConfiguredIpAddress[key] = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress{
		Address: &Address,
	}

	return t.ConfiguredIpAddress[key], nil
}

// RenameConfiguredIpAddress renames an entry in the list ConfiguredIpAddress within
// the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) RenameConfiguredIpAddress(oldK, newK string) error {
	if _, ok := t.ConfiguredIpAddress[newK]; ok {
		return fmt.Errorf("key %v already exists in ConfiguredIpAddress", newK)
	}

	e, ok := t.ConfiguredIpAddress[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ConfiguredIpAddress", oldK)
	}
	e.Address = &newK

	t.ConfiguredIpAddress[newK] = e
	delete(t.ConfiguredIpAddress, oldK)
	return nil
}

// GetOrCreateConfiguredIpAddressMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) GetOrCreateConfiguredIpAddressMap() map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress {
	if t.ConfiguredIpAddress == nil {
		t.ConfiguredIpAddress = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress)
	}
	return t.ConfiguredIpAddress
}

// GetOrCreateConfiguredIpAddress retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) GetOrCreateConfiguredIpAddress(Address string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress {

	key := Address

	if v, ok := t.ConfiguredIpAddress[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewConfiguredIpAddress(Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateConfiguredIpAddress got unexpected error: %v", err))
	}
	return v
}

// GetConfiguredIpAddress retrieves the value with the specified key from
// the ConfiguredIpAddress map field of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) GetConfiguredIpAddress(Address string) *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress {

	if t == nil {
		return nil
	}

	key := Address

	if lm, ok := t.ConfiguredIpAddress[key]; ok {
		return lm
	}
	return nil
}

// AppendConfiguredIpAddress appends the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress struct to the
// list ConfiguredIpAddress of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) AppendConfiguredIpAddress(v *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key received for Address")
	}

	key := *v.Address

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ConfiguredIpAddress == nil {
		t.ConfiguredIpAddress = make(map[string]*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress)
	}

	if _, ok := t.ConfiguredIpAddress[key]; ok {
		return fmt.Errorf("duplicate key for list ConfiguredIpAddress %v", key)
	}

	t.ConfiguredIpAddress[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/configured-ip-addresses/configured-ip-address YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress struct {
	Address           *string                                  `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EncapsulationType E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEncap `path:"encapsulation-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryType         E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEntry `path:"entry-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddress   *string                                  `path:"hardware-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IpAddress         *string                                  `path:"ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	return map[string]interface{}{
		"address": *t.Address,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_ConfiguredIpAddresses_ConfiguredIpAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/interface-configured-ip-addresses YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses struct {
	InterfaceConfiguredIpAddress []*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress `path:"interface-configured-ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/interface-configured-ip-addresses/interface-configured-ip-address YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress struct {
	Address                      *string                                                                                                                           `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	AssociatedConfigurationEntry *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry `path:"associated-configuration-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName                *string                                                                                                                           `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceNameXr              *string                                                                                                                           `path:"interface-name-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ReferenceCount               *uint32                                                                                                                           `path:"reference-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) IsYANGGoStruct() {
}

// GetOrCreateAssociatedConfigurationEntry retrieves the value of the AssociatedConfigurationEntry field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) GetOrCreateAssociatedConfigurationEntry() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry {
	if t.AssociatedConfigurationEntry != nil {
		return t.AssociatedConfigurationEntry
	}
	t.AssociatedConfigurationEntry = &Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry{}
	return t.AssociatedConfigurationEntry
}

// GetAssociatedConfigurationEntry returns the value of the AssociatedConfigurationEntry struct pointer
// from Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress. If the receiver or the field AssociatedConfigurationEntry is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) GetAssociatedConfigurationEntry() *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry {
	if t != nil && t.AssociatedConfigurationEntry != nil {
		return t.AssociatedConfigurationEntry
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/interface-configured-ip-addresses/interface-configured-ip-address/associated-configuration-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry struct {
	EncapsulationType E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEncap `path:"encapsulation-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryType         E_Cisco_IOS_XRIpv4ArpOper_ArpGmpBagEntry `path:"entry-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddress   *string                                  `path:"hardware-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IpAddress         *string                                  `path:"ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_InterfaceConfiguredIpAddresses_InterfaceConfiguredIpAddress_AssociatedConfigurationEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/routes YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes struct {
	Route []*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route `path:"route" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/routes/route YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route struct {
	Address         *string                                                               `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName   []*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceNameXr *string                                                               `path:"interface-name-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IpAddress       *string                                                               `path:"ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PrefixLength    *uint32                                                               `path:"prefix-length" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PrefixLengthXr  *uint8                                                                `path:"prefix-length-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp-gmp/vrfs/vrf/routes/route/interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_ArpGmp_Vrfs_Vrf_Routes_Route_InterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes struct {
	Node map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node `path:"node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) IsYANGGoStruct() {}

// NewNode creates a new entry in the Node list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) NewNode(NodeName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node)
	}

	key := NodeName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Node[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Node", key)
	}

	t.Node[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node{
		NodeName: &NodeName,
	}

	return t.Node[key], nil
}

// RenameNode renames an entry in the list Node within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) RenameNode(oldK, newK string) error {
	if _, ok := t.Node[newK]; ok {
		return fmt.Errorf("key %v already exists in Node", newK)
	}

	e, ok := t.Node[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Node", oldK)
	}
	e.NodeName = &newK

	t.Node[newK] = e
	delete(t.Node, oldK)
	return nil
}

// GetOrCreateNodeMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) GetOrCreateNodeMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node {
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node)
	}
	return t.Node
}

// GetOrCreateNode retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) GetOrCreateNode(NodeName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node {

	key := NodeName

	if v, ok := t.Node[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNode(NodeName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNode got unexpected error: %v", err))
	}
	return v
}

// GetNode retrieves the value with the specified key from
// the Node map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) GetNode(NodeName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node {

	if t == nil {
		return nil
	}

	key := NodeName

	if lm, ok := t.Node[key]; ok {
		return lm
	}
	return nil
}

// AppendNode appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node struct to the
// list Node of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) AppendNode(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) error {
	if v.NodeName == nil {
		return fmt.Errorf("invalid nil key received for NodeName")
	}

	key := *v.NodeName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node)
	}

	if _, ok := t.Node[key]; ok {
		return fmt.Errorf("duplicate key for list Node %v", key)
	}

	t.Node[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node struct {
	AdjacencyHistoryAll                                  *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll                                  `path:"adjacency-history-all" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	AdjacencyHistoryInterfaceNames                       *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames                       `path:"adjacency-history-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpHostTrackingSessions                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions                              `path:"arp-host-tracking-sessions" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpRedSyncGids                                       *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids                                       `path:"arp-red-sync-gids" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpStats                                             *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats                                             `path:"arp-stats" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpStatusInfo                                        *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo                                        `path:"arp-status-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientIds                                            *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds                                            `path:"client-ids" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DirectAttachedGatewayRedundancyInterfaceAndAddresses *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses `path:"direct-attached-gateway-redundancy-interface-and-addresses" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Entries                                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries                                              `path:"entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbEventsInterfaceNames                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames                              `path:"idb-events-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceNames                                    *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames                                    `path:"idb-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NodeName                                             *string                                                                                      `path:"node-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PacketHistoryAll                                     *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll                                     `path:"packet-history-all" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PacketHistoryInterfaceNames                          *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames                          `path:"packet-history-interface-names" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionHistoryClient                              *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient                              `path:"resolution-history-client" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionHistoryDynamic                             *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic                             `path:"resolution-history-dynamic" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadQueueStatistics                                *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics                                `path:"thread-queue-statistics" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TrafficInterfaces                                    *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces                                    `path:"traffic-interfaces" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TrafficNode                                          *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode                                          `path:"traffic-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TrafficVrfs                                          *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs                                          `path:"traffic-vrfs" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) IsYANGGoStruct() {}

// GetOrCreateAdjacencyHistoryAll retrieves the value of the AdjacencyHistoryAll field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateAdjacencyHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll {
	if t.AdjacencyHistoryAll != nil {
		return t.AdjacencyHistoryAll
	}
	t.AdjacencyHistoryAll = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll{}
	return t.AdjacencyHistoryAll
}

// GetOrCreateAdjacencyHistoryInterfaceNames retrieves the value of the AdjacencyHistoryInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateAdjacencyHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames {
	if t.AdjacencyHistoryInterfaceNames != nil {
		return t.AdjacencyHistoryInterfaceNames
	}
	t.AdjacencyHistoryInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames{}
	return t.AdjacencyHistoryInterfaceNames
}

// GetOrCreateArpHostTrackingSessions retrieves the value of the ArpHostTrackingSessions field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpHostTrackingSessions() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions {
	if t.ArpHostTrackingSessions != nil {
		return t.ArpHostTrackingSessions
	}
	t.ArpHostTrackingSessions = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions{}
	return t.ArpHostTrackingSessions
}

// GetOrCreateArpRedSyncGids retrieves the value of the ArpRedSyncGids field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpRedSyncGids() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids {
	if t.ArpRedSyncGids != nil {
		return t.ArpRedSyncGids
	}
	t.ArpRedSyncGids = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids{}
	return t.ArpRedSyncGids
}

// GetOrCreateArpStats retrieves the value of the ArpStats field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpStats() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats {
	if t.ArpStats != nil {
		return t.ArpStats
	}
	t.ArpStats = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats{}
	return t.ArpStats
}

// GetOrCreateArpStatusInfo retrieves the value of the ArpStatusInfo field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateArpStatusInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo {
	if t.ArpStatusInfo != nil {
		return t.ArpStatusInfo
	}
	t.ArpStatusInfo = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo{}
	return t.ArpStatusInfo
}

// GetOrCreateClientIds retrieves the value of the ClientIds field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateClientIds() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds {
	if t.ClientIds != nil {
		return t.ClientIds
	}
	t.ClientIds = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds{}
	return t.ClientIds
}

// GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddresses retrieves the value of the DirectAttachedGatewayRedundancyInterfaceAndAddresses field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddresses() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses {
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddresses != nil {
		return t.DirectAttachedGatewayRedundancyInterfaceAndAddresses
	}
	t.DirectAttachedGatewayRedundancyInterfaceAndAddresses = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses{}
	return t.DirectAttachedGatewayRedundancyInterfaceAndAddresses
}

// GetOrCreateEntries retrieves the value of the Entries field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateEntries() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries {
	if t.Entries != nil {
		return t.Entries
	}
	t.Entries = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries{}
	return t.Entries
}

// GetOrCreateIdbEventsInterfaceNames retrieves the value of the IdbEventsInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateIdbEventsInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames {
	if t.IdbEventsInterfaceNames != nil {
		return t.IdbEventsInterfaceNames
	}
	t.IdbEventsInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames{}
	return t.IdbEventsInterfaceNames
}

// GetOrCreateIdbInterfaceNames retrieves the value of the IdbInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateIdbInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames {
	if t.IdbInterfaceNames != nil {
		return t.IdbInterfaceNames
	}
	t.IdbInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames{}
	return t.IdbInterfaceNames
}

// GetOrCreatePacketHistoryAll retrieves the value of the PacketHistoryAll field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreatePacketHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll {
	if t.PacketHistoryAll != nil {
		return t.PacketHistoryAll
	}
	t.PacketHistoryAll = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll{}
	return t.PacketHistoryAll
}

// GetOrCreatePacketHistoryInterfaceNames retrieves the value of the PacketHistoryInterfaceNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreatePacketHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames {
	if t.PacketHistoryInterfaceNames != nil {
		return t.PacketHistoryInterfaceNames
	}
	t.PacketHistoryInterfaceNames = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames{}
	return t.PacketHistoryInterfaceNames
}

// GetOrCreateResolutionHistoryClient retrieves the value of the ResolutionHistoryClient field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateResolutionHistoryClient() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient {
	if t.ResolutionHistoryClient != nil {
		return t.ResolutionHistoryClient
	}
	t.ResolutionHistoryClient = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient{}
	return t.ResolutionHistoryClient
}

// GetOrCreateResolutionHistoryDynamic retrieves the value of the ResolutionHistoryDynamic field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateResolutionHistoryDynamic() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic {
	if t.ResolutionHistoryDynamic != nil {
		return t.ResolutionHistoryDynamic
	}
	t.ResolutionHistoryDynamic = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic{}
	return t.ResolutionHistoryDynamic
}

// GetOrCreateThreadQueueStatistics retrieves the value of the ThreadQueueStatistics field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateThreadQueueStatistics() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics {
	if t.ThreadQueueStatistics != nil {
		return t.ThreadQueueStatistics
	}
	t.ThreadQueueStatistics = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics{}
	return t.ThreadQueueStatistics
}

// GetOrCreateTrafficInterfaces retrieves the value of the TrafficInterfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateTrafficInterfaces() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces {
	if t.TrafficInterfaces != nil {
		return t.TrafficInterfaces
	}
	t.TrafficInterfaces = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces{}
	return t.TrafficInterfaces
}

// GetOrCreateTrafficNode retrieves the value of the TrafficNode field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateTrafficNode() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode {
	if t.TrafficNode != nil {
		return t.TrafficNode
	}
	t.TrafficNode = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode{}
	return t.TrafficNode
}

// GetOrCreateTrafficVrfs retrieves the value of the TrafficVrfs field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetOrCreateTrafficVrfs() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs {
	if t.TrafficVrfs != nil {
		return t.TrafficVrfs
	}
	t.TrafficVrfs = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs{}
	return t.TrafficVrfs
}

// GetAdjacencyHistoryAll returns the value of the AdjacencyHistoryAll struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field AdjacencyHistoryAll is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetAdjacencyHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll {
	if t != nil && t.AdjacencyHistoryAll != nil {
		return t.AdjacencyHistoryAll
	}
	return nil
}

// GetAdjacencyHistoryInterfaceNames returns the value of the AdjacencyHistoryInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field AdjacencyHistoryInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetAdjacencyHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames {
	if t != nil && t.AdjacencyHistoryInterfaceNames != nil {
		return t.AdjacencyHistoryInterfaceNames
	}
	return nil
}

// GetArpHostTrackingSessions returns the value of the ArpHostTrackingSessions struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpHostTrackingSessions is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpHostTrackingSessions() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions {
	if t != nil && t.ArpHostTrackingSessions != nil {
		return t.ArpHostTrackingSessions
	}
	return nil
}

// GetArpRedSyncGids returns the value of the ArpRedSyncGids struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpRedSyncGids is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpRedSyncGids() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids {
	if t != nil && t.ArpRedSyncGids != nil {
		return t.ArpRedSyncGids
	}
	return nil
}

// GetArpStats returns the value of the ArpStats struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpStats is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpStats() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats {
	if t != nil && t.ArpStats != nil {
		return t.ArpStats
	}
	return nil
}

// GetArpStatusInfo returns the value of the ArpStatusInfo struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ArpStatusInfo is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetArpStatusInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo {
	if t != nil && t.ArpStatusInfo != nil {
		return t.ArpStatusInfo
	}
	return nil
}

// GetClientIds returns the value of the ClientIds struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ClientIds is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetClientIds() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds {
	if t != nil && t.ClientIds != nil {
		return t.ClientIds
	}
	return nil
}

// GetDirectAttachedGatewayRedundancyInterfaceAndAddresses returns the value of the DirectAttachedGatewayRedundancyInterfaceAndAddresses struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field DirectAttachedGatewayRedundancyInterfaceAndAddresses is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetDirectAttachedGatewayRedundancyInterfaceAndAddresses() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses {
	if t != nil && t.DirectAttachedGatewayRedundancyInterfaceAndAddresses != nil {
		return t.DirectAttachedGatewayRedundancyInterfaceAndAddresses
	}
	return nil
}

// GetEntries returns the value of the Entries struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field Entries is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetEntries() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries {
	if t != nil && t.Entries != nil {
		return t.Entries
	}
	return nil
}

// GetIdbEventsInterfaceNames returns the value of the IdbEventsInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field IdbEventsInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetIdbEventsInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames {
	if t != nil && t.IdbEventsInterfaceNames != nil {
		return t.IdbEventsInterfaceNames
	}
	return nil
}

// GetIdbInterfaceNames returns the value of the IdbInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field IdbInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetIdbInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames {
	if t != nil && t.IdbInterfaceNames != nil {
		return t.IdbInterfaceNames
	}
	return nil
}

// GetPacketHistoryAll returns the value of the PacketHistoryAll struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field PacketHistoryAll is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetPacketHistoryAll() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll {
	if t != nil && t.PacketHistoryAll != nil {
		return t.PacketHistoryAll
	}
	return nil
}

// GetPacketHistoryInterfaceNames returns the value of the PacketHistoryInterfaceNames struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field PacketHistoryInterfaceNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetPacketHistoryInterfaceNames() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames {
	if t != nil && t.PacketHistoryInterfaceNames != nil {
		return t.PacketHistoryInterfaceNames
	}
	return nil
}

// GetResolutionHistoryClient returns the value of the ResolutionHistoryClient struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ResolutionHistoryClient is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetResolutionHistoryClient() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient {
	if t != nil && t.ResolutionHistoryClient != nil {
		return t.ResolutionHistoryClient
	}
	return nil
}

// GetResolutionHistoryDynamic returns the value of the ResolutionHistoryDynamic struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ResolutionHistoryDynamic is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetResolutionHistoryDynamic() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic {
	if t != nil && t.ResolutionHistoryDynamic != nil {
		return t.ResolutionHistoryDynamic
	}
	return nil
}

// GetThreadQueueStatistics returns the value of the ThreadQueueStatistics struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field ThreadQueueStatistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetThreadQueueStatistics() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics {
	if t != nil && t.ThreadQueueStatistics != nil {
		return t.ThreadQueueStatistics
	}
	return nil
}

// GetTrafficInterfaces returns the value of the TrafficInterfaces struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field TrafficInterfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetTrafficInterfaces() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces {
	if t != nil && t.TrafficInterfaces != nil {
		return t.TrafficInterfaces
	}
	return nil
}

// GetTrafficNode returns the value of the TrafficNode struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field TrafficNode is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetTrafficNode() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode {
	if t != nil && t.TrafficNode != nil {
		return t.TrafficNode
	}
	return nil
}

// GetTrafficVrfs returns the value of the TrafficVrfs struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node. If the receiver or the field TrafficVrfs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) GetTrafficVrfs() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs {
	if t != nil && t.TrafficVrfs != nil {
		return t.TrafficVrfs
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeName == nil {
		return nil, fmt.Errorf("nil value for key NodeName")
	}

	return map[string]interface{}{
		"node-name": *t.NodeName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-all YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-all/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry struct {
	ClientId         *int32  `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState       *int32  `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address      *string `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress       *string `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Protocol         *int32  `path:"protocol" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Result           *int32  `path:"result" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryAll_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames struct {
	AdjacencyHistoryInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName `path:"adjacency-history-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) IsYANGGoStruct() {}

// NewAdjacencyHistoryInterfaceName creates a new entry in the AdjacencyHistoryInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) NewAdjacencyHistoryInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencyHistoryInterfaceName == nil {
		t.AdjacencyHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AdjacencyHistoryInterfaceName", key)
	}

	t.AdjacencyHistoryInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.AdjacencyHistoryInterfaceName[key], nil
}

// RenameAdjacencyHistoryInterfaceName renames an entry in the list AdjacencyHistoryInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) RenameAdjacencyHistoryInterfaceName(oldK, newK string) error {
	if _, ok := t.AdjacencyHistoryInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in AdjacencyHistoryInterfaceName", newK)
	}

	e, ok := t.AdjacencyHistoryInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AdjacencyHistoryInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.AdjacencyHistoryInterfaceName[newK] = e
	delete(t.AdjacencyHistoryInterfaceName, oldK)
	return nil
}

// GetOrCreateAdjacencyHistoryInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) GetOrCreateAdjacencyHistoryInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName {
	if t.AdjacencyHistoryInterfaceName == nil {
		t.AdjacencyHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName)
	}
	return t.AdjacencyHistoryInterfaceName
}

// GetOrCreateAdjacencyHistoryInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) GetOrCreateAdjacencyHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName {

	key := InterfaceName

	if v, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdjacencyHistoryInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdjacencyHistoryInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetAdjacencyHistoryInterfaceName retrieves the value with the specified key from
// the AdjacencyHistoryInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) GetAdjacencyHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendAdjacencyHistoryInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName struct to the
// list AdjacencyHistoryInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) AppendAdjacencyHistoryInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AdjacencyHistoryInterfaceName == nil {
		t.AdjacencyHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName)
	}

	if _, ok := t.AdjacencyHistoryInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list AdjacencyHistoryInterfaceName %v", key)
	}

	t.AdjacencyHistoryInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-interface-names/adjacency-history-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName struct {
	ArpEntry      []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string                                                                                                         `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/adjacency-history-interface-names/adjacency-history-interface-name/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry struct {
	ClientId         *int32  `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState       *int32  `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address      *string `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress       *string `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Protocol         *int32  `path:"protocol" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Result           *int32  `path:"result" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_AdjacencyHistoryInterfaceNames_AdjacencyHistoryInterfaceName_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-host-tracking-sessions YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions struct {
	ArpHostTrackingSession map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession `path:"arp-host-tracking-session" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) IsYANGGoStruct() {}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key represents the key for list ArpHostTrackingSession of element /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-host-tracking-sessions.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key struct {
	InterfaceName string `path:"interface-name"`
	Address       string `path:"address"`
}

// IsYANGGoKeyStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key) IsYANGGoKeyStruct() {
}

// ΛListKeyMap returns the values of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key key struct.
func (t Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"interface-name": t.InterfaceName,
		"address":        t.Address,
	}, nil
}

// NewArpHostTrackingSession creates a new entry in the ArpHostTrackingSession list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) NewArpHostTrackingSession(InterfaceName string, Address string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpHostTrackingSession == nil {
		t.ArpHostTrackingSession = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession)
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ArpHostTrackingSession[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ArpHostTrackingSession", key)
	}

	t.ArpHostTrackingSession[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession{
		InterfaceName: &InterfaceName,
		Address:       &Address,
	}

	return t.ArpHostTrackingSession[key], nil
}

// RenameArpHostTrackingSession renames an entry in the list ArpHostTrackingSession within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) RenameArpHostTrackingSession(oldK, newK Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key) error {
	if _, ok := t.ArpHostTrackingSession[newK]; ok {
		return fmt.Errorf("key %v already exists in ArpHostTrackingSession", newK)
	}

	e, ok := t.ArpHostTrackingSession[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ArpHostTrackingSession", oldK)
	}
	e.InterfaceName = &newK.InterfaceName
	e.Address = &newK.Address

	t.ArpHostTrackingSession[newK] = e
	delete(t.ArpHostTrackingSession, oldK)
	return nil
}

// GetOrCreateArpHostTrackingSessionMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) GetOrCreateArpHostTrackingSessionMap() map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession {
	if t.ArpHostTrackingSession == nil {
		t.ArpHostTrackingSession = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession)
	}
	return t.ArpHostTrackingSession
}

// GetOrCreateArpHostTrackingSession retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) GetOrCreateArpHostTrackingSession(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession {

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if v, ok := t.ArpHostTrackingSession[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewArpHostTrackingSession(InterfaceName, Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateArpHostTrackingSession got unexpected error: %v", err))
	}
	return v
}

// GetArpHostTrackingSession retrieves the value with the specified key from
// the ArpHostTrackingSession map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) GetArpHostTrackingSession(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession {

	if t == nil {
		return nil
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if lm, ok := t.ArpHostTrackingSession[key]; ok {
		return lm
	}
	return nil
}

// AppendArpHostTrackingSession appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession struct to the
// list ArpHostTrackingSession of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) AppendArpHostTrackingSession(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key for InterfaceName")
	}

	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key{
		InterfaceName: *v.InterfaceName,
		Address:       *v.Address,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpHostTrackingSession == nil {
		t.ArpHostTrackingSession = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession)
	}

	if _, ok := t.ArpHostTrackingSession[key]; ok {
		return fmt.Errorf("duplicate key for list ArpHostTrackingSession %v", key)
	}

	t.ArpHostTrackingSession[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-host-tracking-sessions/arp-host-tracking-session YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession struct {
	Address          *string                                       `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DestAddress      *string                                       `path:"dest-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string                                       `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName    *string                                       `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	State            E_Cisco_IOS_XRIpv4ArpOper_IpArpHostTrackState `path:"state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"address":        *t.Address,
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpHostTrackingSessions_ArpHostTrackingSession) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-red-sync-gids YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids struct {
	ArpRedSyncGid map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid `path:"arp-red-sync-gid" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) IsYANGGoStruct() {}

// NewArpRedSyncGid creates a new entry in the ArpRedSyncGid list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) NewArpRedSyncGid(GroupId uint32) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpRedSyncGid == nil {
		t.ArpRedSyncGid = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid)
	}

	key := GroupId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ArpRedSyncGid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ArpRedSyncGid", key)
	}

	t.ArpRedSyncGid[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid{
		GroupId: &GroupId,
	}

	return t.ArpRedSyncGid[key], nil
}

// RenameArpRedSyncGid renames an entry in the list ArpRedSyncGid within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) RenameArpRedSyncGid(oldK, newK uint32) error {
	if _, ok := t.ArpRedSyncGid[newK]; ok {
		return fmt.Errorf("key %v already exists in ArpRedSyncGid", newK)
	}

	e, ok := t.ArpRedSyncGid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ArpRedSyncGid", oldK)
	}
	e.GroupId = &newK

	t.ArpRedSyncGid[newK] = e
	delete(t.ArpRedSyncGid, oldK)
	return nil
}

// GetOrCreateArpRedSyncGidMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) GetOrCreateArpRedSyncGidMap() map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid {
	if t.ArpRedSyncGid == nil {
		t.ArpRedSyncGid = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid)
	}
	return t.ArpRedSyncGid
}

// GetOrCreateArpRedSyncGid retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) GetOrCreateArpRedSyncGid(GroupId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid {

	key := GroupId

	if v, ok := t.ArpRedSyncGid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewArpRedSyncGid(GroupId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateArpRedSyncGid got unexpected error: %v", err))
	}
	return v
}

// GetArpRedSyncGid retrieves the value with the specified key from
// the ArpRedSyncGid map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) GetArpRedSyncGid(GroupId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid {

	if t == nil {
		return nil
	}

	key := GroupId

	if lm, ok := t.ArpRedSyncGid[key]; ok {
		return lm
	}
	return nil
}

// AppendArpRedSyncGid appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid struct to the
// list ArpRedSyncGid of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) AppendArpRedSyncGid(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) error {
	if v.GroupId == nil {
		return fmt.Errorf("invalid nil key received for GroupId")
	}

	key := *v.GroupId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ArpRedSyncGid == nil {
		t.ArpRedSyncGid = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid)
	}

	if _, ok := t.ArpRedSyncGid[key]; ok {
		return fmt.Errorf("duplicate key for list ArpRedSyncGid %v", key)
	}

	t.ArpRedSyncGid[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-red-sync-gids/arp-red-sync-gid YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid struct {
	GroupId    *uint32                                    `path:"group-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GroupIdXr  *uint16                                    `path:"group-id-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeerAdd    *string                                    `path:"peer-add" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeerStatus E_Cisco_IOS_XRIpv4ArpOper_ArpPeerStatusBag `path:"peer-status" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrcIntName *string                                    `path:"src-int-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛListKeyMap() (map[string]interface{}, error) {
	if t.GroupId == nil {
		return nil, fmt.Errorf("nil value for key GroupId")
	}

	return map[string]interface{}{
		"group-id": *t.GroupId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpRedSyncGids_ArpRedSyncGid) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-stats YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStats) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-status-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo struct {
	AllIdbClientResyncTime                 *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime `path:"all-idb-client-resync-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BigBangTime                            *uint64                                                                      `path:"big-bang-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntriesRecoveredCount           *uint32                                                                      `path:"dynamic-entries-recovered-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceHandleTranslationFailureCount *uint32                                                                      `path:"interface-handle-translation-failure-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyDagrRib                       *bool                                                                        `path:"issu-ready-dagr-rib" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyEntriesReplicate              *bool                                                                        `path:"issu-ready-entries-replicate" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyIm                            *bool                                                                        `path:"issu-ready-im" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyIssuMgrConnection             *bool                                                                        `path:"issu-ready-issu-mgr-connection" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuReadyTime                          *uint64                                                                      `path:"issu-ready-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IssuSyncCompleteTime                   *uint64                                                                      `path:"issu-sync-complete-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NonOperationalEntriesCount             *uint32                                                                      `path:"non-operational-entries-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Phase                                  E_Cisco_IOS_XRIpv4ArpOper_ArpIssuPhase                                       `path:"phase" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PrimaryRoleTime                        *uint64                                                                      `path:"primary-role-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProcessStartTime                       *uint64                                                                      `path:"process-start-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Role                                   E_Cisco_IOS_XRIpv4ArpOper_ArpIssuRole                                        `path:"role" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Version                                E_Cisco_IOS_XRIpv4ArpOper_ArpIssuVersion                                     `path:"version" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) IsYANGGoStruct() {}

// GetOrCreateAllIdbClientResyncTime retrieves the value of the AllIdbClientResyncTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) GetOrCreateAllIdbClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime {
	if t.AllIdbClientResyncTime != nil {
		return t.AllIdbClientResyncTime
	}
	t.AllIdbClientResyncTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime{}
	return t.AllIdbClientResyncTime
}

// GetAllIdbClientResyncTime returns the value of the AllIdbClientResyncTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo. If the receiver or the field AllIdbClientResyncTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) GetAllIdbClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime {
	if t != nil && t.AllIdbClientResyncTime != nil {
		return t.AllIdbClientResyncTime
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/arp-status-info/all-idb-client-resync-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ArpStatusInfo_AllIdbClientResyncTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/client-ids YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds struct {
	ClientId map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) IsYANGGoStruct() {}

// NewClientId creates a new entry in the ClientId list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) NewClientId(ClientId uint32) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientId == nil {
		t.ClientId = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId)
	}

	key := ClientId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ClientId[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ClientId", key)
	}

	t.ClientId[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId{
		ClientId: &ClientId,
	}

	return t.ClientId[key], nil
}

// RenameClientId renames an entry in the list ClientId within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) RenameClientId(oldK, newK uint32) error {
	if _, ok := t.ClientId[newK]; ok {
		return fmt.Errorf("key %v already exists in ClientId", newK)
	}

	e, ok := t.ClientId[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ClientId", oldK)
	}
	e.ClientId = &newK

	t.ClientId[newK] = e
	delete(t.ClientId, oldK)
	return nil
}

// GetOrCreateClientIdMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) GetOrCreateClientIdMap() map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId {
	if t.ClientId == nil {
		t.ClientId = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId)
	}
	return t.ClientId
}

// GetOrCreateClientId retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) GetOrCreateClientId(ClientId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId {

	key := ClientId

	if v, ok := t.ClientId[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewClientId(ClientId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateClientId got unexpected error: %v", err))
	}
	return v
}

// GetClientId retrieves the value with the specified key from
// the ClientId map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) GetClientId(ClientId uint32) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId {

	if t == nil {
		return nil
	}

	key := ClientId

	if lm, ok := t.ClientId[key]; ok {
		return lm
	}
	return nil
}

// AppendClientId appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId struct to the
// list ClientId of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) AppendClientId(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) error {
	if v.ClientId == nil {
		return fmt.Errorf("invalid nil key received for ClientId")
	}

	key := *v.ClientId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientId == nil {
		t.ClientId = make(map[uint32]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId)
	}

	if _, ok := t.ClientId[key]; ok {
		return fmt.Errorf("duplicate key for list ClientId %v", key)
	}

	t.ClientId[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/client-ids/client-id YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId struct {
	ClientId       *uint32 `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientIdXr     *uint32 `path:"client-id-xr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntriesAdded   *uint32 `path:"entries-added" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntriesDeleted *uint32 `path:"entries-deleted" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RegTime        *uint64 `path:"reg-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SendRequest    *uint32 `path:"send-request" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	UnregTime      *uint64 `path:"unreg-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ClientId == nil {
		return nil, fmt.Errorf("nil value for key ClientId")
	}

	return map[string]interface{}{
		"client-id": *t.ClientId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ClientIds_ClientId) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/direct-attached-gateway-redundancy-interface-and-addresses YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses struct {
	DirectAttachedGatewayRedundancyInterfaceAndAddress map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress `path:"direct-attached-gateway-redundancy-interface-and-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) IsYANGGoStruct() {
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key represents the key for list DirectAttachedGatewayRedundancyInterfaceAndAddress of element /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/direct-attached-gateway-redundancy-interface-and-addresses.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key struct {
	InterfaceName string `path:"interface-name"`
	Address       string `path:"address"`
}

// IsYANGGoKeyStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key) IsYANGGoKeyStruct() {
}

// ΛListKeyMap returns the values of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key key struct.
func (t Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"interface-name": t.InterfaceName,
		"address":        t.Address,
	}, nil
}

// NewDirectAttachedGatewayRedundancyInterfaceAndAddress creates a new entry in the DirectAttachedGatewayRedundancyInterfaceAndAddress list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) NewDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName string, Address string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddress == nil {
		t.DirectAttachedGatewayRedundancyInterfaceAndAddress = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress)
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list DirectAttachedGatewayRedundancyInterfaceAndAddress", key)
	}

	t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress{
		InterfaceName: &InterfaceName,
		Address:       &Address,
	}

	return t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key], nil
}

// RenameDirectAttachedGatewayRedundancyInterfaceAndAddress renames an entry in the list DirectAttachedGatewayRedundancyInterfaceAndAddress within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) RenameDirectAttachedGatewayRedundancyInterfaceAndAddress(oldK, newK Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key) error {
	if _, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[newK]; ok {
		return fmt.Errorf("key %v already exists in DirectAttachedGatewayRedundancyInterfaceAndAddress", newK)
	}

	e, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in DirectAttachedGatewayRedundancyInterfaceAndAddress", oldK)
	}
	e.InterfaceName = &newK.InterfaceName
	e.Address = &newK.Address

	t.DirectAttachedGatewayRedundancyInterfaceAndAddress[newK] = e
	delete(t.DirectAttachedGatewayRedundancyInterfaceAndAddress, oldK)
	return nil
}

// GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddressMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddressMap() map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress {
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddress == nil {
		t.DirectAttachedGatewayRedundancyInterfaceAndAddress = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress)
	}
	return t.DirectAttachedGatewayRedundancyInterfaceAndAddress
}

// GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddress retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress {

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if v, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName, Address)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDirectAttachedGatewayRedundancyInterfaceAndAddress got unexpected error: %v", err))
	}
	return v
}

// GetDirectAttachedGatewayRedundancyInterfaceAndAddress retrieves the value with the specified key from
// the DirectAttachedGatewayRedundancyInterfaceAndAddress map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) GetDirectAttachedGatewayRedundancyInterfaceAndAddress(InterfaceName string, Address string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress {

	if t == nil {
		return nil
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: InterfaceName,
		Address:       Address,
	}

	if lm, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return lm
	}
	return nil
}

// AppendDirectAttachedGatewayRedundancyInterfaceAndAddress appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress struct to the
// list DirectAttachedGatewayRedundancyInterfaceAndAddress of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) AppendDirectAttachedGatewayRedundancyInterfaceAndAddress(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key for InterfaceName")
	}

	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key{
		InterfaceName: *v.InterfaceName,
		Address:       *v.Address,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.DirectAttachedGatewayRedundancyInterfaceAndAddress == nil {
		t.DirectAttachedGatewayRedundancyInterfaceAndAddress = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress)
	}

	if _, ok := t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key]; ok {
		return fmt.Errorf("duplicate key for list DirectAttachedGatewayRedundancyInterfaceAndAddress %v", key)
	}

	t.DirectAttachedGatewayRedundancyInterfaceAndAddress[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/direct-attached-gateway-redundancy-interface-and-addresses/direct-attached-gateway-redundancy-interface-and-address YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress struct {
	Address       *string `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Dist          *uint32 `path:"dist" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ifhandle      *string `path:"ifhandle" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Metric        *uint32 `path:"metric" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QueryPeriod   *uint32 `path:"query-period" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	State         *string `path:"state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Vip           *string `path:"vip" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"address":        *t.Address,
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_DirectAttachedGatewayRedundancyInterfaceAndAddresses_DirectAttachedGatewayRedundancyInterfaceAndAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/entries YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries struct {
	Entry map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry `path:"entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) IsYANGGoStruct() {}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key represents the key for list Entry of element /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/entries.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key struct {
	Address       string `path:"address"`
	InterfaceName string `path:"interface-name"`
}

// IsYANGGoKeyStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key partially implements the
// yang.GoKeyStruct interface. This allows functions that need to
// handle this key struct to identify it as being generated by gogen.
func (Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key) IsYANGGoKeyStruct() {}

// ΛListKeyMap returns the values of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key key struct.
func (t Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key) ΛListKeyMap() (map[string]interface{}, error) {
	return map[string]interface{}{
		"address":        t.Address,
		"interface-name": t.InterfaceName,
	}, nil
}

// NewEntry creates a new entry in the Entry list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) NewEntry(Address string, InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry)
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       Address,
		InterfaceName: InterfaceName,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry{
		Address:       &Address,
		InterfaceName: &InterfaceName,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) RenameEntry(oldK, newK Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Address = &newK.Address
	e.InterfaceName = &newK.InterfaceName

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntryMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) GetOrCreateEntryMap() map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry {
	if t.Entry == nil {
		t.Entry = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry)
	}
	return t.Entry
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) GetOrCreateEntry(Address string, InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry {

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       Address,
		InterfaceName: InterfaceName,
	}

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Address, InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) GetEntry(Address string, InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry {

	if t == nil {
		return nil
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       Address,
		InterfaceName: InterfaceName,
	}

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// AppendEntry appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry struct to the
// list Entry of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) AppendEntry(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) error {
	if v.Address == nil {
		return fmt.Errorf("invalid nil key for Address")
	}

	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key for InterfaceName")
	}

	key := Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key{
		Address:       *v.Address,
		InterfaceName: *v.InterfaceName,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry_Key]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/entries/entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry struct {
	Address           *string                                 `path:"address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Age               *uint64                                 `path:"age" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EncapsulationType E_Cisco_IOS_XRIpv4ArpOper_IpArpBagEncap `path:"encapsulation-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Flag              E_Cisco_IOS_XRIpv4ArpOper_IpArpBagFlags `path:"flag" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddress   *string                                 `path:"hardware-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareLength    *uint8                                  `path:"hardware-length" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName     *string                                 `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MediaType         E_Cisco_IOS_XRIpv4ArpOper_IpArpBagMedia `path:"media-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	State             E_Cisco_IOS_XRIpv4ArpOper_IpArpBagState `path:"state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Address == nil {
		return nil, fmt.Errorf("nil value for key Address")
	}

	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"address":        *t.Address,
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_Entries_Entry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-events-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames struct {
	IdbEventsInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName `path:"idb-events-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) IsYANGGoStruct() {}

// NewIdbEventsInterfaceName creates a new entry in the IdbEventsInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) NewIdbEventsInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbEventsInterfaceName == nil {
		t.IdbEventsInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IdbEventsInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IdbEventsInterfaceName", key)
	}

	t.IdbEventsInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.IdbEventsInterfaceName[key], nil
}

// RenameIdbEventsInterfaceName renames an entry in the list IdbEventsInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) RenameIdbEventsInterfaceName(oldK, newK string) error {
	if _, ok := t.IdbEventsInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in IdbEventsInterfaceName", newK)
	}

	e, ok := t.IdbEventsInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IdbEventsInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.IdbEventsInterfaceName[newK] = e
	delete(t.IdbEventsInterfaceName, oldK)
	return nil
}

// GetOrCreateIdbEventsInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) GetOrCreateIdbEventsInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName {
	if t.IdbEventsInterfaceName == nil {
		t.IdbEventsInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName)
	}
	return t.IdbEventsInterfaceName
}

// GetOrCreateIdbEventsInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) GetOrCreateIdbEventsInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName {

	key := InterfaceName

	if v, ok := t.IdbEventsInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIdbEventsInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIdbEventsInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetIdbEventsInterfaceName retrieves the value with the specified key from
// the IdbEventsInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) GetIdbEventsInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.IdbEventsInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendIdbEventsInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName struct to the
// list IdbEventsInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) AppendIdbEventsInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbEventsInterfaceName == nil {
		t.IdbEventsInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName)
	}

	if _, ok := t.IdbEventsInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list IdbEventsInterfaceName %v", key)
	}

	t.IdbEventsInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-events-interface-names/idb-events-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName struct {
	EvtClassName  *string                                                                                           `path:"evt-class-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtEntry      []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry `path:"evt-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string                                                                                           `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-events-interface-names/idb-events-interface-name/evt-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry struct {
	EvtData      []uint32 `path:"evt-data" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtMany      *bool    `path:"evt-many" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtName      *string  `path:"evt-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtSticky    *bool    `path:"evt-sticky" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtTimestamp *string  `path:"evt-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtType      *uint8   `path:"evt-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbEventsInterfaceNames_IdbEventsInterfaceName_EvtEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames struct {
	IdbInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) IsYANGGoStruct() {}

// NewIdbInterfaceName creates a new entry in the IdbInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) NewIdbInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbInterfaceName == nil {
		t.IdbInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IdbInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IdbInterfaceName", key)
	}

	t.IdbInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.IdbInterfaceName[key], nil
}

// RenameIdbInterfaceName renames an entry in the list IdbInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) RenameIdbInterfaceName(oldK, newK string) error {
	if _, ok := t.IdbInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in IdbInterfaceName", newK)
	}

	e, ok := t.IdbInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IdbInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.IdbInterfaceName[newK] = e
	delete(t.IdbInterfaceName, oldK)
	return nil
}

// GetOrCreateIdbInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) GetOrCreateIdbInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName {
	if t.IdbInterfaceName == nil {
		t.IdbInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName)
	}
	return t.IdbInterfaceName
}

// GetOrCreateIdbInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) GetOrCreateIdbInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName {

	key := InterfaceName

	if v, ok := t.IdbInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIdbInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIdbInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetIdbInterfaceName retrieves the value with the specified key from
// the IdbInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) GetIdbInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.IdbInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendIdbInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName struct to the
// list IdbInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) AppendIdbInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IdbInterfaceName == nil {
		t.IdbInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName)
	}

	if _, ok := t.IdbInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list IdbInterfaceName %v", key)
	}

	t.IdbInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName struct {
	BfdMinInterval                    *uint32                                                                                     `path:"bfd-min-interval" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BfdMultiplier                     *uint8                                                                                      `path:"bfd-multiplier" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BfdSrcIpAddr                      *string                                                                                     `path:"bfd-src-ip-addr" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	BroadcastDisabled                 *bool                                                                                       `path:"broadcast-disabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CacheLimit                        *uint32                                                                                     `path:"cache-limit" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CapsulationState                  *uint32                                                                                     `path:"capsulation-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientId                          *uint32                                                                                     `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ClientResyncTime                  *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime `path:"client-resync-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CompleteGleanCount                *uint32                                                                                     `path:"complete-glean-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	CompleteProtocolCount             *uint32                                                                                     `path:"complete-protocol-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjTimeout                    *uint32                                                                                     `path:"drop-adj-timeout" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DroppedGleanCount                 *uint32                                                                                     `path:"dropped-glean-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DroppedProtocolCount              *uint32                                                                                     `path:"dropped-protocol-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	HardwareAddressKnown              *bool                                                                                       `path:"hardware-address-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbEventHistory                   *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory  `path:"idb-event-history" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbFlag                           *uint32                                                                                     `path:"idb-flag" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbFlagExt                        *uint32                                                                                     `path:"idb-flag-ext" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName                  *string                                                                                     `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbIpAddress                      *string                                                                                     `path:"idb-ip-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbTimeout                        *uint32                                                                                     `path:"idb-timeout" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IncompleteGleanCount              *uint32                                                                                     `path:"incomplete-glean-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName                     *string                                                                                     `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4CapsulationKnown              *bool                                                                                       `path:"ipv4-capsulation-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsComplete                        *bool                                                                                       `path:"is-complete" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsDynamicLearningEnabled          *bool                                                                                       `path:"is-dynamic-learning-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsDynamicLearningLocalEnabled     *bool                                                                                       `path:"is-dynamic-learning-local-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsDynamicLearningSolicitedEnabled *bool                                                                                       `path:"is-dynamic-learning-solicited-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsIdbForwardReferenced            *bool                                                                                       `path:"is-idb-forward-referenced" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsIpv4Unnumbered                  *bool                                                                                       `path:"is-ipv4-unnumbered" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsLocalProxyConfigured            *bool                                                                                       `path:"is-local-proxy-configured" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsProxyConfigured                 *bool                                                                                       `path:"is-proxy-configured" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsProxyEnabled                    *bool                                                                                       `path:"is-proxy-enabled" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsPurgeDelayConfigured            *bool                                                                                       `path:"is-purge-delay-configured" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsUsingSpio                       *bool                                                                                       `path:"is-using-spio" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IsVirtual                         *bool                                                                                       `path:"is-virtual" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MediaKnown                        *bool                                                                                       `path:"media-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MplsCapsulationKnown              *bool                                                                                       `path:"mpls-capsulation-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OperProgress                      E_Cisco_IOS_XRIpv4ArpOper_ArpImOperBag                                                      `path:"oper-progress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProbeInterval                     *uint32                                                                                     `path:"probe-interval" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProbeRetries                      *uint8                                                                                      `path:"probe-retries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PurgeDelay                        *uint32                                                                                     `path:"purge-delay" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SpioAttachError                   *uint32                                                                                     `path:"spio-attach-error" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrgRole                           *uint8                                                                                      `path:"srg-role" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VlanidKnown                       *bool                                                                                       `path:"vlanid-known" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfId                             *uint32                                                                                     `path:"vrf-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName                           *string                                                                                     `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) IsYANGGoStruct() {}

// GetOrCreateClientResyncTime retrieves the value of the ClientResyncTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetOrCreateClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime {
	if t.ClientResyncTime != nil {
		return t.ClientResyncTime
	}
	t.ClientResyncTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime{}
	return t.ClientResyncTime
}

// GetOrCreateIdbEventHistory retrieves the value of the IdbEventHistory field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetOrCreateIdbEventHistory() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory {
	if t.IdbEventHistory != nil {
		return t.IdbEventHistory
	}
	t.IdbEventHistory = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory{}
	return t.IdbEventHistory
}

// GetClientResyncTime returns the value of the ClientResyncTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName. If the receiver or the field ClientResyncTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetClientResyncTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime {
	if t != nil && t.ClientResyncTime != nil {
		return t.ClientResyncTime
	}
	return nil
}

// GetIdbEventHistory returns the value of the IdbEventHistory struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName. If the receiver or the field IdbEventHistory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) GetIdbEventHistory() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory {
	if t != nil && t.IdbEventHistory != nil {
		return t.IdbEventHistory
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name/client-resync-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_ClientResyncTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name/idb-event-history YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory struct {
	EvtClassName *string                                                                                               `path:"evt-class-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtEntry     []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry `path:"evt-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}
