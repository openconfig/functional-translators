/*
Package native is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /usr/local/google/home/singhavnish/go/pkg/mod/github.com/openconfig/ygot@v0.33.0/genutil/names.go
using the following YANG input files:
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ifmgr-cfg.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-infra-statsd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-infra-statsd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ip-iarm-datatypes.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper-sub3.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-arp-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper-sub2.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv4-io-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper-sub1.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-ipv6-nd-oper.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-subscriber-infra-tmplmgr-cfg.yang
  - yang/vendor/cisco/xr/2431/Cisco-IOS-XR-types.yang
  - yang/vendor/cisco/xr/2431/cisco-semver.yang
  - yang/vendor/cisco/xr/2431/ietf-inet-types.yang

Imported modules were sourced from:
  - yang/vendor/cisco/xr/2431/...
*/
package native

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/idb-interface-names/idb-interface-name/idb-event-history/evt-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry struct {
	EvtData      []uint32 `path:"evt-data" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtMany      *bool    `path:"evt-many" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtName      *string  `path:"evt-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtSticky    *bool    `path:"evt-sticky" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtTimestamp *string  `path:"evt-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EvtType      *uint8   `path:"evt-type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_IdbInterfaceNames_IdbInterfaceName_IdbEventHistory_EvtEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-all YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-all/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry struct {
	DsTaddress       *string `path:"ds-taddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DstMac           *string `path:"dst-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Mode             *int32  `path:"mode" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrCaddress       *string `path:"sr-caddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrcMac           *string `path:"src-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryAll_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-interface-names YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames struct {
	PacketHistoryInterfaceName map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName `path:"packet-history-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) IsYANGGoStruct() {}

// NewPacketHistoryInterfaceName creates a new entry in the PacketHistoryInterfaceName list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) NewPacketHistoryInterfaceName(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PacketHistoryInterfaceName == nil {
		t.PacketHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PacketHistoryInterfaceName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PacketHistoryInterfaceName", key)
	}

	t.PacketHistoryInterfaceName[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName{
		InterfaceName: &InterfaceName,
	}

	return t.PacketHistoryInterfaceName[key], nil
}

// RenamePacketHistoryInterfaceName renames an entry in the list PacketHistoryInterfaceName within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) RenamePacketHistoryInterfaceName(oldK, newK string) error {
	if _, ok := t.PacketHistoryInterfaceName[newK]; ok {
		return fmt.Errorf("key %v already exists in PacketHistoryInterfaceName", newK)
	}

	e, ok := t.PacketHistoryInterfaceName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PacketHistoryInterfaceName", oldK)
	}
	e.InterfaceName = &newK

	t.PacketHistoryInterfaceName[newK] = e
	delete(t.PacketHistoryInterfaceName, oldK)
	return nil
}

// GetOrCreatePacketHistoryInterfaceNameMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) GetOrCreatePacketHistoryInterfaceNameMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName {
	if t.PacketHistoryInterfaceName == nil {
		t.PacketHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName)
	}
	return t.PacketHistoryInterfaceName
}

// GetOrCreatePacketHistoryInterfaceName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) GetOrCreatePacketHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName {

	key := InterfaceName

	if v, ok := t.PacketHistoryInterfaceName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPacketHistoryInterfaceName(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePacketHistoryInterfaceName got unexpected error: %v", err))
	}
	return v
}

// GetPacketHistoryInterfaceName retrieves the value with the specified key from
// the PacketHistoryInterfaceName map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) GetPacketHistoryInterfaceName(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.PacketHistoryInterfaceName[key]; ok {
		return lm
	}
	return nil
}

// AppendPacketHistoryInterfaceName appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName struct to the
// list PacketHistoryInterfaceName of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) AppendPacketHistoryInterfaceName(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PacketHistoryInterfaceName == nil {
		t.PacketHistoryInterfaceName = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName)
	}

	if _, ok := t.PacketHistoryInterfaceName[key]; ok {
		return fmt.Errorf("duplicate key for list PacketHistoryInterfaceName %v", key)
	}

	t.PacketHistoryInterfaceName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-interface-names/packet-history-interface-name YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName struct {
	ArpEntry      []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName *string                                                                                                   `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/packet-history-interface-names/packet-history-interface-name/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry struct {
	DsTaddress       *string `path:"ds-taddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DstMac           *string `path:"dst-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName *string `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Mode             *int32  `path:"mode" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp    *uint64 `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrCaddress       *string `path:"sr-caddress" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SrcMac           *string `path:"src-mac" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Type             *int32  `path:"type" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_PacketHistoryInterfaceNames_PacketHistoryInterfaceName_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-client YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-client/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry struct {
	ClientId               *int32                                               `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState             *int32                                               `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName       *string                                              `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address            *string                                              `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress             *string                                              `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp          *uint64                                              `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestCount *uint32                                              `path:"resolution-request-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Status                 E_Cisco_IOS_XRIpv4ArpOper_ArpResolutionHistoryStatus `path:"status" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryClient_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-dynamic YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic struct {
	ArpEntry []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry `path:"arp-entry" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/resolution-history-dynamic/arp-entry YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry struct {
	ClientId               *int32                                               `path:"client-id" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	EntryState             *int32                                               `path:"entry-state" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbInterfaceName       *string                                              `path:"idb-interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4Address            *string                                              `path:"ipv4-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MacAddress             *string                                              `path:"mac-address" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NsecTimestamp          *uint64                                              `path:"nsec-timestamp" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestCount *uint32                                              `path:"resolution-request-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Status                 E_Cisco_IOS_XRIpv4ArpOper_ArpResolutionHistoryStatus `path:"status" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ResolutionHistoryDynamic_ArpEntry) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics struct {
	InputPacketDropCount   *uint64                                                                          `path:"input-packet-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LastInputPulseTime     *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime `path:"last-input-pulse-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LastPuntPulseTime      *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime  `path:"last-punt-pulse-time" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PuntPacketDropCount    *uint64                                                                          `path:"punt-packet-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QueueMsg               []*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg         `path:"queue-msg" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalDropCount         *uint64                                                                          `path:"total-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	UnknownPacketDropCount *uint64                                                                          `path:"unknown-packet-drop-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) IsYANGGoStruct() {}

// GetOrCreateLastInputPulseTime retrieves the value of the LastInputPulseTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetOrCreateLastInputPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime {
	if t.LastInputPulseTime != nil {
		return t.LastInputPulseTime
	}
	t.LastInputPulseTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime{}
	return t.LastInputPulseTime
}

// GetOrCreateLastPuntPulseTime retrieves the value of the LastPuntPulseTime field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetOrCreateLastPuntPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime {
	if t.LastPuntPulseTime != nil {
		return t.LastPuntPulseTime
	}
	t.LastPuntPulseTime = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime{}
	return t.LastPuntPulseTime
}

// GetLastInputPulseTime returns the value of the LastInputPulseTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics. If the receiver or the field LastInputPulseTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetLastInputPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime {
	if t != nil && t.LastInputPulseTime != nil {
		return t.LastInputPulseTime
	}
	return nil
}

// GetLastPuntPulseTime returns the value of the LastPuntPulseTime struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics. If the receiver or the field LastPuntPulseTime is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) GetLastPuntPulseTime() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime {
	if t != nil && t.LastPuntPulseTime != nil {
		return t.LastPuntPulseTime
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/last-input-pulse-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastInputPulseTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/last-punt-pulse-time YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime struct {
	Nanoseconds *uint32 `path:"nanoseconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Seconds     *uint32 `path:"seconds" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_LastPuntPulseTime) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/queue-msg YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg struct {
	CurrentElementInfo *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo `path:"current-element-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OldElementInfo     *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo     `path:"old-element-info" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadName         *string                                                                                   `path:"thread-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) IsYANGGoStruct() {}

// GetOrCreateCurrentElementInfo retrieves the value of the CurrentElementInfo field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetOrCreateCurrentElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo {
	if t.CurrentElementInfo != nil {
		return t.CurrentElementInfo
	}
	t.CurrentElementInfo = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo{}
	return t.CurrentElementInfo
}

// GetOrCreateOldElementInfo retrieves the value of the OldElementInfo field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetOrCreateOldElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo {
	if t.OldElementInfo != nil {
		return t.OldElementInfo
	}
	t.OldElementInfo = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo{}
	return t.OldElementInfo
}

// GetCurrentElementInfo returns the value of the CurrentElementInfo struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg. If the receiver or the field CurrentElementInfo is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetCurrentElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo {
	if t != nil && t.CurrentElementInfo != nil {
		return t.CurrentElementInfo
	}
	return nil
}

// GetOldElementInfo returns the value of the OldElementInfo struct pointer
// from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg. If the receiver or the field OldElementInfo is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) GetOldElementInfo() *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo {
	if t != nil && t.OldElementInfo != nil {
		return t.OldElementInfo
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/queue-msg/current-element-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo struct {
	DqCount           *uint32 `path:"dq-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MsgsEnqueuedCount *uint32 `path:"msgs-enqueued-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoQCount          *uint32 `path:"no-q-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeakQSize         *uint32 `path:"peak-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseRecvdCount   *uint32 `path:"pulse-recvd-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseSentCount    *uint32 `path:"pulse-sent-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QblockedCount     *uint32 `path:"qblocked-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QreleasedCount    *uint32 `path:"qreleased-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SelfPulseCount    *uint32 `path:"self-pulse-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadQSize       *uint32 `path:"thread-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_CurrentElementInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/thread-queue-statistics/queue-msg/old-element-info YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo struct {
	DqCount           *uint32 `path:"dq-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	MsgsEnqueuedCount *uint32 `path:"msgs-enqueued-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoQCount          *uint32 `path:"no-q-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PeakQSize         *uint32 `path:"peak-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseRecvdCount   *uint32 `path:"pulse-recvd-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	PulseSentCount    *uint32 `path:"pulse-sent-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QblockedCount     *uint32 `path:"qblocked-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	QreleasedCount    *uint32 `path:"qreleased-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SelfPulseCount    *uint32 `path:"self-pulse-count" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ThreadQSize       *uint32 `path:"thread-q-size" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_ThreadQueueStatistics_QueueMsg_OldElementInfo) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-interfaces YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces struct {
	TrafficInterface map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface `path:"traffic-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) IsYANGGoStruct() {}

// NewTrafficInterface creates a new entry in the TrafficInterface list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) NewTrafficInterface(InterfaceName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficInterface == nil {
		t.TrafficInterface = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrafficInterface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrafficInterface", key)
	}

	t.TrafficInterface[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface{
		InterfaceName: &InterfaceName,
	}

	return t.TrafficInterface[key], nil
}

// RenameTrafficInterface renames an entry in the list TrafficInterface within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) RenameTrafficInterface(oldK, newK string) error {
	if _, ok := t.TrafficInterface[newK]; ok {
		return fmt.Errorf("key %v already exists in TrafficInterface", newK)
	}

	e, ok := t.TrafficInterface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrafficInterface", oldK)
	}
	e.InterfaceName = &newK

	t.TrafficInterface[newK] = e
	delete(t.TrafficInterface, oldK)
	return nil
}

// GetOrCreateTrafficInterfaceMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) GetOrCreateTrafficInterfaceMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface {
	if t.TrafficInterface == nil {
		t.TrafficInterface = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface)
	}
	return t.TrafficInterface
}

// GetOrCreateTrafficInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) GetOrCreateTrafficInterface(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface {

	key := InterfaceName

	if v, ok := t.TrafficInterface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrafficInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrafficInterface got unexpected error: %v", err))
	}
	return v
}

// GetTrafficInterface retrieves the value with the specified key from
// the TrafficInterface map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) GetTrafficInterface(InterfaceName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.TrafficInterface[key]; ok {
		return lm
	}
	return nil
}

// AppendTrafficInterface appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface struct to the
// list TrafficInterface of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) AppendTrafficInterface(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficInterface == nil {
		t.TrafficInterface = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface)
	}

	if _, ok := t.TrafficInterface[key]; ok {
		return fmt.Errorf("duplicate key for list TrafficInterface %v", key)
	}

	t.TrafficInterface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-interfaces/traffic-interface YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceName                 *string `path:"interface-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficInterfaces_TrafficInterface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-node YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficNode) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-vrfs YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs struct {
	TrafficVrf map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf `path:"traffic-vrf" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) IsYANGGoStruct() {}

// NewTrafficVrf creates a new entry in the TrafficVrf list of the
// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) NewTrafficVrf(VrfName string) (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficVrf == nil {
		t.TrafficVrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrafficVrf[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrafficVrf", key)
	}

	t.TrafficVrf[key] = &Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf{
		VrfName: &VrfName,
	}

	return t.TrafficVrf[key], nil
}

// RenameTrafficVrf renames an entry in the list TrafficVrf within
// the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) RenameTrafficVrf(oldK, newK string) error {
	if _, ok := t.TrafficVrf[newK]; ok {
		return fmt.Errorf("key %v already exists in TrafficVrf", newK)
	}

	e, ok := t.TrafficVrf[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrafficVrf", oldK)
	}
	e.VrfName = &newK

	t.TrafficVrf[newK] = e
	delete(t.TrafficVrf, oldK)
	return nil
}

// GetOrCreateTrafficVrfMap returns the list (map) from Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) GetOrCreateTrafficVrfMap() map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf {
	if t.TrafficVrf == nil {
		t.TrafficVrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf)
	}
	return t.TrafficVrf
}

// GetOrCreateTrafficVrf retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) GetOrCreateTrafficVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf {

	key := VrfName

	if v, ok := t.TrafficVrf[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrafficVrf(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrafficVrf got unexpected error: %v", err))
	}
	return v
}

// GetTrafficVrf retrieves the value with the specified key from
// the TrafficVrf map field of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) GetTrafficVrf(VrfName string) *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.TrafficVrf[key]; ok {
		return lm
	}
	return nil
}

// AppendTrafficVrf appends the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf struct to the
// list TrafficVrf of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) AppendTrafficVrf(v *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrafficVrf == nil {
		t.TrafficVrf = make(map[string]*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf)
	}

	if _, ok := t.TrafficVrf[key]; ok {
		return fmt.Errorf("duplicate key for list TrafficVrf %v", key)
	}

	t.TrafficVrf[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf represents the /Cisco-IOS-XR-ipv4-arp-oper/arp/nodes/node/traffic-vrfs/traffic-vrf YANG schema element.
type Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf struct {
	AliasEntries                  *uint32 `path:"alias-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketInterfaceOutOfSubnet *uint32 `path:"arp-packet-interface-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketNodeOutOfSubnet      *uint32 `path:"arp-packet-node-out-of-subnet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPacketUnsolicitedPacket    *uint32 `path:"arp-packet-unsolicited-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerAllowedPacket       *uint32 `path:"arp-policer-allowed-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpPolicerDroppedPacket       *uint32 `path:"arp-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpevpnProxyReplies           *uint32 `path:"arpevpn-proxy-replies" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpipPolicerDroppedPacket     *uint32 `path:"arpip-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ArpmacPolicerDroppedPacket    *uint32 `path:"arpmac-policer-dropped-packet" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DhcpEntries                   *uint32 `path:"dhcp-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DropAdjacencyEntries          *uint32 `path:"drop-adjacency-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	DynamicEntries                *uint32 `path:"dynamic-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	GratuitousRepliesSent         *uint32 `path:"gratuitous-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	IdbStructures                 *uint32 `path:"idb-structures" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	InterfaceEntries              *uint32 `path:"interface-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedInterface   *uint32 `path:"ipv4-packets-dropped-interface" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	Ipv4PacketsDroppedNode        *uint32 `path:"ipv4-packets-dropped-node" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	LocalProxyRepliesSent         *uint32 `path:"local-proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	NoBufferErrors                *uint32 `path:"no-buffer-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	OutOfMemoryErrors             *uint32 `path:"out-of-memory-errors" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ProxyRepliesSent              *uint32 `path:"proxy-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesReceived               *uint32 `path:"replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RepliesSent                   *uint32 `path:"replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsReceived              *uint32 `path:"requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	RequestsSent                  *uint32 `path:"requests-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRepliesReceived     *uint32 `path:"resolution-replies-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsDropped     *uint32 `path:"resolution-requests-dropped" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	ResolutionRequestsReceived    *uint32 `path:"resolution-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StandbyEntries                *uint32 `path:"standby-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	StaticEntries                 *uint32 `path:"static-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesGratgSent        *uint32 `path:"subscr-replies-gratg-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRepliesSent             *uint32 `path:"subscr-replies-sent" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	SubscrRequestsReceived        *uint32 `path:"subscr-requests-received" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	TotalEntries                  *uint32 `path:"total-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VrfName                       *string `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-arp-oper"`
	VxlanEntries                  *uint32 `path:"vxlan-entries" module:"Cisco-IOS-XR-ipv4-arp-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) IsYANGGoStruct() {}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf.
func (*Cisco_IOS_XRIpv4ArpOper_Arp_Nodes_Node_TrafficVrfs_TrafficVrf) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-arp-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network struct {
	Nodes *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes `path:"nodes" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network) IsYANGGoStruct() {}

// GetOrCreateNodes retrieves the value of the Nodes field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network) GetOrCreateNodes() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes {
	if t.Nodes != nil {
		return t.Nodes
	}
	t.Nodes = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes{}
	return t.Nodes
}

// GetNodes returns the value of the Nodes struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network. If the receiver or the field Nodes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network) GetNodes() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes {
	if t != nil && t.Nodes != nil {
		return t.Nodes
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes struct {
	Node map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node `path:"node" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) IsYANGGoStruct() {}

// NewNode creates a new entry in the Node list of the
// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) NewNode(NodeName string) (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node)
	}

	key := NodeName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Node[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Node", key)
	}

	t.Node[key] = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node{
		NodeName: &NodeName,
	}

	return t.Node[key], nil
}

// RenameNode renames an entry in the list Node within
// the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) RenameNode(oldK, newK string) error {
	if _, ok := t.Node[newK]; ok {
		return fmt.Errorf("key %v already exists in Node", newK)
	}

	e, ok := t.Node[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Node", oldK)
	}
	e.NodeName = &newK

	t.Node[newK] = e
	delete(t.Node, oldK)
	return nil
}

// GetOrCreateNodeMap returns the list (map) from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) GetOrCreateNodeMap() map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node {
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node)
	}
	return t.Node
}

// GetOrCreateNode retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) GetOrCreateNode(NodeName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node {

	key := NodeName

	if v, ok := t.Node[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNode(NodeName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNode got unexpected error: %v", err))
	}
	return v
}

// GetNode retrieves the value with the specified key from
// the Node map field of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) GetNode(NodeName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node {

	if t == nil {
		return nil
	}

	key := NodeName

	if lm, ok := t.Node[key]; ok {
		return lm
	}
	return nil
}

// AppendNode appends the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node struct to the
// list Node of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) AppendNode(v *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) error {
	if v.NodeName == nil {
		return fmt.Errorf("invalid nil key received for NodeName")
	}

	key := *v.NodeName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Node == nil {
		t.Node = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node)
	}

	if _, ok := t.Node[key]; ok {
		return fmt.Errorf("duplicate key for list Node %v", key)
	}

	t.Node[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node struct {
	InterfaceData *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData `path:"interface-data" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NodeName      *string                                                      `path:"node-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Statistics    *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics    `path:"statistics" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) IsYANGGoStruct() {}

// GetOrCreateInterfaceData retrieves the value of the InterfaceData field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) GetOrCreateInterfaceData() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData {
	if t.InterfaceData != nil {
		return t.InterfaceData
	}
	t.InterfaceData = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData{}
	return t.InterfaceData
}

// GetOrCreateStatistics retrieves the value of the Statistics field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) GetOrCreateStatistics() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics {
	if t.Statistics != nil {
		return t.Statistics
	}
	t.Statistics = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics{}
	return t.Statistics
}

// GetInterfaceData returns the value of the InterfaceData struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node. If the receiver or the field InterfaceData is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) GetInterfaceData() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData {
	if t != nil && t.InterfaceData != nil {
		return t.InterfaceData
	}
	return nil
}

// GetStatistics returns the value of the Statistics struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node. If the receiver or the field Statistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) GetStatistics() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_Statistics {
	if t != nil && t.Statistics != nil {
		return t.Statistics
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) ΛListKeyMap() (map[string]interface{}, error) {
	if t.NodeName == nil {
		return nil, fmt.Errorf("nil value for key NodeName")
	}

	return map[string]interface{}{
		"node-name": *t.NodeName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData struct {
	Interfaces *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces `path:"interfaces" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Summary    *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary    `path:"summary" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Vrfs       *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs       `path:"vrfs" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) IsYANGGoStruct() {}

// GetOrCreateInterfaces retrieves the value of the Interfaces field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) GetOrCreateInterfaces() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces {
	if t.Interfaces != nil {
		return t.Interfaces
	}
	t.Interfaces = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces{}
	return t.Interfaces
}

// GetOrCreateSummary retrieves the value of the Summary field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) GetOrCreateSummary() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary {
	if t.Summary != nil {
		return t.Summary
	}
	t.Summary = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary{}
	return t.Summary
}

// GetOrCreateVrfs retrieves the value of the Vrfs field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) GetOrCreateVrfs() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs {
	if t.Vrfs != nil {
		return t.Vrfs
	}
	t.Vrfs = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs{}
	return t.Vrfs
}

// GetInterfaces returns the value of the Interfaces struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData. If the receiver or the field Interfaces is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) GetInterfaces() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces {
	if t != nil && t.Interfaces != nil {
		return t.Interfaces
	}
	return nil
}

// GetSummary returns the value of the Summary struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData. If the receiver or the field Summary is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) GetSummary() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary {
	if t != nil && t.Summary != nil {
		return t.Summary
	}
	return nil
}

// GetVrfs returns the value of the Vrfs struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData. If the receiver or the field Vrfs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) GetVrfs() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs {
	if t != nil && t.Vrfs != nil {
		return t.Vrfs
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces struct {
	Interface map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface `path:"interface" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) IsYANGGoStruct() {}

// NewInterface creates a new entry in the Interface list of the
// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) NewInterface(InterfaceName string) (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Interface[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Interface", key)
	}

	t.Interface[key] = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface{
		InterfaceName: &InterfaceName,
	}

	return t.Interface[key], nil
}

// RenameInterface renames an entry in the list Interface within
// the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) RenameInterface(oldK, newK string) error {
	if _, ok := t.Interface[newK]; ok {
		return fmt.Errorf("key %v already exists in Interface", newK)
	}

	e, ok := t.Interface[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Interface", oldK)
	}
	e.InterfaceName = &newK

	t.Interface[newK] = e
	delete(t.Interface, oldK)
	return nil
}

// GetOrCreateInterfaceMap returns the list (map) from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) GetOrCreateInterfaceMap() map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface {
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface)
	}
	return t.Interface
}

// GetOrCreateInterface retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) GetOrCreateInterface(InterfaceName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface {

	key := InterfaceName

	if v, ok := t.Interface[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewInterface(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateInterface got unexpected error: %v", err))
	}
	return v
}

// GetInterface retrieves the value with the specified key from
// the Interface map field of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) GetInterface(InterfaceName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.Interface[key]; ok {
		return lm
	}
	return nil
}

// AppendInterface appends the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface struct to the
// list Interface of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) AppendInterface(v *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Interface == nil {
		t.Interface = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface)
	}

	if _, ok := t.Interface[key]; ok {
		return fmt.Errorf("duplicate key for list Interface %v", key)
	}

	t.Interface[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface struct {
	InterfaceName *string                                                                                    `path:"interface-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfNames      *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames `path:"vrf-names" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) IsYANGGoStruct() {
}

// GetOrCreateVrfNames retrieves the value of the VrfNames field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) GetOrCreateVrfNames() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames {
	if t.VrfNames != nil {
		return t.VrfNames
	}
	t.VrfNames = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames{}
	return t.VrfNames
}

// GetVrfNames returns the value of the VrfNames struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface. If the receiver or the field VrfNames is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) GetVrfNames() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames {
	if t != nil && t.VrfNames != nil {
		return t.VrfNames
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames struct {
	VrfName map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) IsYANGGoStruct() {
}

// NewVrfName creates a new entry in the VrfName list of the
// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) NewVrfName(VrfName string) (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrfName == nil {
		t.VrfName = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VrfName[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VrfName", key)
	}

	t.VrfName[key] = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName{
		VrfName: &VrfName,
	}

	return t.VrfName[key], nil
}

// RenameVrfName renames an entry in the list VrfName within
// the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) RenameVrfName(oldK, newK string) error {
	if _, ok := t.VrfName[newK]; ok {
		return fmt.Errorf("key %v already exists in VrfName", newK)
	}

	e, ok := t.VrfName[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VrfName", oldK)
	}
	e.VrfName = &newK

	t.VrfName[newK] = e
	delete(t.VrfName, oldK)
	return nil
}

// GetOrCreateVrfNameMap returns the list (map) from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) GetOrCreateVrfNameMap() map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName {
	if t.VrfName == nil {
		t.VrfName = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName)
	}
	return t.VrfName
}

// GetOrCreateVrfName retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) GetOrCreateVrfName(VrfName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName {

	key := VrfName

	if v, ok := t.VrfName[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrfName(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrfName got unexpected error: %v", err))
	}
	return v
}

// GetVrfName retrieves the value with the specified key from
// the VrfName map field of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) GetVrfName(VrfName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.VrfName[key]; ok {
		return lm
	}
	return nil
}

// AppendVrfName appends the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName struct to the
// list VrfName of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) AppendVrfName(v *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VrfName == nil {
		t.VrfName = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName)
	}

	if _, ok := t.VrfName[key]; ok {
		return fmt.Errorf("duplicate key for list VrfName %v", key)
	}

	t.VrfName[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName struct {
	BriefData  *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData  `path:"brief-data" module:"Cisco-IOS-XR-ipv4-io-oper"`
	DetailData *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData `path:"detail-data" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfName    *string                                                                                                       `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) IsYANGGoStruct() {
}

// GetOrCreateBriefData retrieves the value of the BriefData field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) GetOrCreateBriefData() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData {
	if t.BriefData != nil {
		return t.BriefData
	}
	t.BriefData = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData{}
	return t.BriefData
}

// GetOrCreateDetailData retrieves the value of the DetailData field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) GetOrCreateDetailData() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData {
	if t.DetailData != nil {
		return t.DetailData
	}
	t.DetailData = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData{}
	return t.DetailData
}

// GetBriefData returns the value of the BriefData struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName. If the receiver or the field BriefData is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) GetBriefData() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData {
	if t != nil && t.BriefData != nil {
		return t.BriefData
	}
	return nil
}

// GetDetailData returns the value of the DetailData struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName. If the receiver or the field DetailData is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) GetDetailData() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData {
	if t != nil && t.DetailData != nil {
		return t.DetailData
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/brief-data YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData struct {
	PrimaryAddress *string                              `path:"primary-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProtocolState  E_Cisco_IOS_XRIpv4IoOper_Ipv4MaState `path:"protocol-state" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfId          *uint32                              `path:"vrf-id" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfName        *string                              `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_BriefData) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData struct {
	Acl                         *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl                `path:"acl" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Algorithm                   *uint32                                                                                                                          `path:"algorithm" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ArmFlags                    *uint16                                                                                                                          `path:"arm-flags" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ArpEvpnProxyEnabled         *bool                                                                                                                            `path:"arp-evpn-proxy-enabled" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BgpPa                       *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa              `path:"bgp-pa" module:"Cisco-IOS-XR-ipv4-io-oper"`
	CflctAddress                *string                                                                                                                          `path:"cflct-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ClientType                  E_Cisco_IOS_XRIpv4IoOper_Ipv4MaOperConfig                                                                                        `path:"client-type" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ConfigFlags                 *uint16                                                                                                                          `path:"config-flags" module:"Cisco-IOS-XR-ipv4-io-oper"`
	DirectBroadcast             *bool                                                                                                                            `path:"direct-broadcast" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FlowTagDst                  *bool                                                                                                                            `path:"flow-tag-dst" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FlowTagSrc                  *bool                                                                                                                            `path:"flow-tag-src" module:"Cisco-IOS-XR-ipv4-io-oper"`
	GwAddressRcvd               *bool                                                                                                                            `path:"gw-address-rcvd" module:"Cisco-IOS-XR-ipv4-io-oper"`
	GwPrefixLength              *uint32                                                                                                                          `path:"gw-prefix-length" module:"Cisco-IOS-XR-ipv4-io-oper"`
	HelperAddress               *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress      `path:"helper-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IdbPointer                  *uint64                                                                                                                          `path:"idb-pointer" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IsOrEvent                   *bool                                                                                                                            `path:"is-or-event" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MaskReply                   *bool                                                                                                                            `path:"mask-reply" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MlacpActive                 *bool                                                                                                                            `path:"mlacp-active" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Mtu                         *uint32                                                                                                                          `path:"mtu" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MultiAcl                    *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl           `path:"multi-acl" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MulticastGroup              []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup   `path:"multicast-group" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NextUnnumberedInterfaceName *string                                                                                                                          `path:"next-unnumbered-interface-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OperFlags                   *uint64                                                                                                                          `path:"oper-flags" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OrImState                   E_Cisco_IOS_XRIpv4IoOper_ImStateEnum                                                                                             `path:"or-im-state" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OrImStateConstraint         E_Cisco_IOS_XRIpv4IoOper_ImStateEnum                                                                                             `path:"or-im-state-constraint" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OrImStateRcvd               E_Cisco_IOS_XRIpv4IoOper_ImStateEnum                                                                                             `path:"or-im-state-rcvd" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PrefixLength                *uint32                                                                                                                          `path:"prefix-length" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PrimaryAddress              *string                                                                                                                          `path:"primary-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProtocolState               E_Cisco_IOS_XRIpv4IoOper_Ipv4MaState                                                                                             `path:"protocol-state" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProxyArpDisabled            *bool                                                                                                                            `path:"proxy-arp-disabled" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Redirect                    *bool                                                                                                                            `path:"redirect" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RgIdExists                  *bool                                                                                                                            `path:"rg-id-exists" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RouteTag                    *uint32                                                                                                                          `path:"route-tag" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Rpf                         *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf                `path:"rpf" module:"Cisco-IOS-XR-ipv4-io-oper"`
	SecondaryAddress            []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress `path:"secondary-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	SubGwAddress                *string                                                                                                                          `path:"sub-gw-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	UnnumberedInterfaceName     *string                                                                                                                          `path:"unnumbered-interface-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Unreachable                 *bool                                                                                                                            `path:"unreachable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfId                       *uint32                                                                                                                          `path:"vrf-id" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) IsYANGGoStruct() {
}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetOrCreateAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl{}
	return t.Acl
}

// GetOrCreateBgpPa retrieves the value of the BgpPa field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetOrCreateBgpPa() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa {
	if t.BgpPa != nil {
		return t.BgpPa
	}
	t.BgpPa = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa{}
	return t.BgpPa
}

// GetOrCreateHelperAddress retrieves the value of the HelperAddress field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetOrCreateHelperAddress() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress {
	if t.HelperAddress != nil {
		return t.HelperAddress
	}
	t.HelperAddress = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress{}
	return t.HelperAddress
}

// GetOrCreateMultiAcl retrieves the value of the MultiAcl field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetOrCreateMultiAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl {
	if t.MultiAcl != nil {
		return t.MultiAcl
	}
	t.MultiAcl = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl{}
	return t.MultiAcl
}

// GetOrCreateRpf retrieves the value of the Rpf field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetOrCreateRpf() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf {
	if t.Rpf != nil {
		return t.Rpf
	}
	t.Rpf = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf{}
	return t.Rpf
}

// GetAcl returns the value of the Acl struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetBgpPa returns the value of the BgpPa struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData. If the receiver or the field BgpPa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetBgpPa() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa {
	if t != nil && t.BgpPa != nil {
		return t.BgpPa
	}
	return nil
}

// GetHelperAddress returns the value of the HelperAddress struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData. If the receiver or the field HelperAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetHelperAddress() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress {
	if t != nil && t.HelperAddress != nil {
		return t.HelperAddress
	}
	return nil
}

// GetMultiAcl returns the value of the MultiAcl struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData. If the receiver or the field MultiAcl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetMultiAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl {
	if t != nil && t.MultiAcl != nil {
		return t.MultiAcl
	}
	return nil
}

// GetRpf returns the value of the Rpf struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData. If the receiver or the field Rpf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) GetRpf() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf {
	if t != nil && t.Rpf != nil {
		return t.Rpf
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/acl YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl struct {
	CommonInBound  *string `path:"common-in-bound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	CommonOutBound *string `path:"common-out-bound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Inbound        *string `path:"inbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Outbound       *string `path:"outbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Acl) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/bgp-pa YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa struct {
	Input  *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input  `path:"input" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Output *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output `path:"output" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) IsYANGGoStruct() {
}

// GetOrCreateInput retrieves the value of the Input field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) GetOrCreateInput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input {
	if t.Input != nil {
		return t.Input
	}
	t.Input = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input{}
	return t.Input
}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) GetOrCreateOutput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output{}
	return t.Output
}

// GetInput returns the value of the Input struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa. If the receiver or the field Input is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) GetInput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input {
	if t != nil && t.Input != nil {
		return t.Input
	}
	return nil
}

// GetOutput returns the value of the Output struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) GetOutput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/bgp-pa/input YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input struct {
	Destination *bool `path:"destination" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Enable      *bool `path:"enable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Source      *bool `path:"source" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Input) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/bgp-pa/output YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output struct {
	Destination *bool `path:"destination" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Enable      *bool `path:"enable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Source      *bool `path:"source" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_BgpPa_Output) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/helper-address YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress struct {
	AddressArray []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray `path:"address-array" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/helper-address/address-array YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_HelperAddress_AddressArray) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/multi-acl YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl struct {
	Common   []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common   `path:"common" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Inbound  []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound  `path:"inbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Outbound []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound `path:"outbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/multi-acl/common YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Common) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/multi-acl/inbound YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Inbound) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/multi-acl/outbound YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound struct {
	Entry *string `path:"entry" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MultiAcl_Outbound) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/multicast-group YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup struct {
	GroupAddress *string `path:"group-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_MulticastGroup) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/rpf YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf struct {
	AllowDefaultRoute *bool                            `path:"allow-default-route" module:"Cisco-IOS-XR-ipv4-io-oper"`
	AllowSelfPing     *bool                            `path:"allow-self-ping" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Enable            *bool                            `path:"enable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Mode              E_Cisco_IOS_XRIpv4IoOper_RpfMode `path:"mode" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_Rpf) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/interfaces/interface/vrf-names/vrf-name/detail-data/secondary-address YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress struct {
	Address      *string `path:"address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Algorithm    *uint32 `path:"algorithm" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PrefixLength *uint32 `path:"prefix-length" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RouteTag     *uint32 `path:"route-tag" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Interfaces_Interface_VrfNames_VrfName_DetailData_SecondaryAddress) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/summary YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary struct {
	IfDownDown         *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown     `path:"if-down-down" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IfShutdownDown     *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown `path:"if-shutdown-down" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IfUpDown           *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown       `path:"if-up-down" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IfUpDownBasecapsUp *uint32                                                                             `path:"if-up-down-basecaps-up" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IfUpUp             *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp         `path:"if-up-up" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) IsYANGGoStruct() {}

// GetOrCreateIfDownDown retrieves the value of the IfDownDown field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetOrCreateIfDownDown() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown {
	if t.IfDownDown != nil {
		return t.IfDownDown
	}
	t.IfDownDown = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown{}
	return t.IfDownDown
}

// GetOrCreateIfShutdownDown retrieves the value of the IfShutdownDown field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetOrCreateIfShutdownDown() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown {
	if t.IfShutdownDown != nil {
		return t.IfShutdownDown
	}
	t.IfShutdownDown = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown{}
	return t.IfShutdownDown
}

// GetOrCreateIfUpDown retrieves the value of the IfUpDown field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetOrCreateIfUpDown() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown {
	if t.IfUpDown != nil {
		return t.IfUpDown
	}
	t.IfUpDown = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown{}
	return t.IfUpDown
}

// GetOrCreateIfUpUp retrieves the value of the IfUpUp field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetOrCreateIfUpUp() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp {
	if t.IfUpUp != nil {
		return t.IfUpUp
	}
	t.IfUpUp = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp{}
	return t.IfUpUp
}

// GetIfDownDown returns the value of the IfDownDown struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary. If the receiver or the field IfDownDown is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetIfDownDown() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown {
	if t != nil && t.IfDownDown != nil {
		return t.IfDownDown
	}
	return nil
}

// GetIfShutdownDown returns the value of the IfShutdownDown struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary. If the receiver or the field IfShutdownDown is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetIfShutdownDown() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown {
	if t != nil && t.IfShutdownDown != nil {
		return t.IfShutdownDown
	}
	return nil
}

// GetIfUpDown returns the value of the IfUpDown struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary. If the receiver or the field IfUpDown is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetIfUpDown() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown {
	if t != nil && t.IfUpDown != nil {
		return t.IfUpDown
	}
	return nil
}

// GetIfUpUp returns the value of the IfUpUp struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary. If the receiver or the field IfUpUp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) GetIfUpUp() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp {
	if t != nil && t.IfUpUp != nil {
		return t.IfUpUp
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/summary/if-down-down YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown struct {
	IpAssigned   *uint32 `path:"ip-assigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnassigned *uint32 `path:"ip-unassigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnnumbered *uint32 `path:"ip-unnumbered" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfDownDown) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/summary/if-shutdown-down YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown struct {
	IpAssigned   *uint32 `path:"ip-assigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnassigned *uint32 `path:"ip-unassigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnnumbered *uint32 `path:"ip-unnumbered" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfShutdownDown) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/summary/if-up-down YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown struct {
	IpAssigned   *uint32 `path:"ip-assigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnassigned *uint32 `path:"ip-unassigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnnumbered *uint32 `path:"ip-unnumbered" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpDown) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/summary/if-up-up YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp struct {
	IpAssigned   *uint32 `path:"ip-assigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnassigned *uint32 `path:"ip-unassigned" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IpUnnumbered *uint32 `path:"ip-unnumbered" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp) IsYANGGoStruct() {}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Summary_IfUpUp) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs struct {
	Vrf map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf `path:"vrf" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) IsYANGGoStruct() {}

// NewVrf creates a new entry in the Vrf list of the
// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) NewVrf(VrfName string) (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf)
	}

	key := VrfName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vrf[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vrf", key)
	}

	t.Vrf[key] = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf{
		VrfName: &VrfName,
	}

	return t.Vrf[key], nil
}

// RenameVrf renames an entry in the list Vrf within
// the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) RenameVrf(oldK, newK string) error {
	if _, ok := t.Vrf[newK]; ok {
		return fmt.Errorf("key %v already exists in Vrf", newK)
	}

	e, ok := t.Vrf[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vrf", oldK)
	}
	e.VrfName = &newK

	t.Vrf[newK] = e
	delete(t.Vrf, oldK)
	return nil
}

// GetOrCreateVrfMap returns the list (map) from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) GetOrCreateVrfMap() map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf {
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf)
	}
	return t.Vrf
}

// GetOrCreateVrf retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) GetOrCreateVrf(VrfName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf {

	key := VrfName

	if v, ok := t.Vrf[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrf(VrfName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrf got unexpected error: %v", err))
	}
	return v
}

// GetVrf retrieves the value with the specified key from
// the Vrf map field of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) GetVrf(VrfName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf {

	if t == nil {
		return nil
	}

	key := VrfName

	if lm, ok := t.Vrf[key]; ok {
		return lm
	}
	return nil
}

// AppendVrf appends the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf struct to the
// list Vrf of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) AppendVrf(v *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) error {
	if v.VrfName == nil {
		return fmt.Errorf("invalid nil key received for VrfName")
	}

	key := *v.VrfName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrf == nil {
		t.Vrf = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf)
	}

	if _, ok := t.Vrf[key]; ok {
		return fmt.Errorf("duplicate key for list Vrf %v", key)
	}

	t.Vrf[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf struct {
	Briefs  *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs  `path:"briefs" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Details *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details `path:"details" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfName *string                                                                       `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) IsYANGGoStruct() {}

// GetOrCreateBriefs retrieves the value of the Briefs field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) GetOrCreateBriefs() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs {
	if t.Briefs != nil {
		return t.Briefs
	}
	t.Briefs = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs{}
	return t.Briefs
}

// GetOrCreateDetails retrieves the value of the Details field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) GetOrCreateDetails() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details {
	if t.Details != nil {
		return t.Details
	}
	t.Details = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details{}
	return t.Details
}

// GetBriefs returns the value of the Briefs struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf. If the receiver or the field Briefs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) GetBriefs() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs {
	if t != nil && t.Briefs != nil {
		return t.Briefs
	}
	return nil
}

// GetDetails returns the value of the Details struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf. If the receiver or the field Details is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) GetDetails() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details {
	if t != nil && t.Details != nil {
		return t.Details
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) ΛListKeyMap() (map[string]interface{}, error) {
	if t.VrfName == nil {
		return nil, fmt.Errorf("nil value for key VrfName")
	}

	return map[string]interface{}{
		"vrf-name": *t.VrfName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/briefs YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs struct {
	Brief map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief `path:"brief" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) IsYANGGoStruct() {
}

// NewBrief creates a new entry in the Brief list of the
// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) NewBrief(InterfaceName string) (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Brief == nil {
		t.Brief = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Brief[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Brief", key)
	}

	t.Brief[key] = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief{
		InterfaceName: &InterfaceName,
	}

	return t.Brief[key], nil
}

// RenameBrief renames an entry in the list Brief within
// the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) RenameBrief(oldK, newK string) error {
	if _, ok := t.Brief[newK]; ok {
		return fmt.Errorf("key %v already exists in Brief", newK)
	}

	e, ok := t.Brief[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Brief", oldK)
	}
	e.InterfaceName = &newK

	t.Brief[newK] = e
	delete(t.Brief, oldK)
	return nil
}

// GetOrCreateBriefMap returns the list (map) from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) GetOrCreateBriefMap() map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief {
	if t.Brief == nil {
		t.Brief = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief)
	}
	return t.Brief
}

// GetOrCreateBrief retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) GetOrCreateBrief(InterfaceName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief {

	key := InterfaceName

	if v, ok := t.Brief[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBrief(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBrief got unexpected error: %v", err))
	}
	return v
}

// GetBrief retrieves the value with the specified key from
// the Brief map field of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) GetBrief(InterfaceName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.Brief[key]; ok {
		return lm
	}
	return nil
}

// AppendBrief appends the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief struct to the
// list Brief of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) AppendBrief(v *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Brief == nil {
		t.Brief = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief)
	}

	if _, ok := t.Brief[key]; ok {
		return fmt.Errorf("duplicate key for list Brief %v", key)
	}

	t.Brief[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/briefs/brief YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief struct {
	InterfaceName  *string                              `path:"interface-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PrimaryAddress *string                              `path:"primary-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProtocolState  E_Cisco_IOS_XRIpv4IoOper_Ipv4MaState `path:"protocol-state" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfId          *uint32                              `path:"vrf-id" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfName        *string                              `path:"vrf-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief) IsYANGGoStruct() {
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Briefs_Brief) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details struct {
	Detail map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail `path:"detail" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) IsYANGGoStruct() {
}

// NewDetail creates a new entry in the Detail list of the
// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details struct. The keys of the list are populated from the input
// arguments.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) NewDetail(InterfaceName string) (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Detail == nil {
		t.Detail = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail)
	}

	key := InterfaceName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Detail[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Detail", key)
	}

	t.Detail[key] = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail{
		InterfaceName: &InterfaceName,
	}

	return t.Detail[key], nil
}

// RenameDetail renames an entry in the list Detail within
// the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) RenameDetail(oldK, newK string) error {
	if _, ok := t.Detail[newK]; ok {
		return fmt.Errorf("key %v already exists in Detail", newK)
	}

	e, ok := t.Detail[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Detail", oldK)
	}
	e.InterfaceName = &newK

	t.Detail[newK] = e
	delete(t.Detail, oldK)
	return nil
}

// GetOrCreateDetailMap returns the list (map) from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details.
//
// It initializes the field if not already initialized.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) GetOrCreateDetailMap() map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail {
	if t.Detail == nil {
		t.Detail = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail)
	}
	return t.Detail
}

// GetOrCreateDetail retrieves the value with the specified keys from
// the receiver Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) GetOrCreateDetail(InterfaceName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail {

	key := InterfaceName

	if v, ok := t.Detail[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDetail(InterfaceName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDetail got unexpected error: %v", err))
	}
	return v
}

// GetDetail retrieves the value with the specified key from
// the Detail map field of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) GetDetail(InterfaceName string) *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail {

	if t == nil {
		return nil
	}

	key := InterfaceName

	if lm, ok := t.Detail[key]; ok {
		return lm
	}
	return nil
}

// AppendDetail appends the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail struct to the
// list Detail of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details. If the key value(s) specified in
// the supplied Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail already exist in the list, an error is
// returned.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) AppendDetail(v *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) error {
	if v.InterfaceName == nil {
		return fmt.Errorf("invalid nil key received for InterfaceName")
	}

	key := *v.InterfaceName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Detail == nil {
		t.Detail = make(map[string]*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail)
	}

	if _, ok := t.Detail[key]; ok {
		return fmt.Errorf("duplicate key for list Detail %v", key)
	}

	t.Detail[key] = v
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail struct {
	Acl                         *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl                `path:"acl" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Algorithm                   *uint32                                                                                                 `path:"algorithm" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ArmFlags                    *uint16                                                                                                 `path:"arm-flags" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ArpEvpnProxyEnabled         *bool                                                                                                   `path:"arp-evpn-proxy-enabled" module:"Cisco-IOS-XR-ipv4-io-oper"`
	BgpPa                       *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa              `path:"bgp-pa" module:"Cisco-IOS-XR-ipv4-io-oper"`
	CflctAddress                *string                                                                                                 `path:"cflct-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ClientType                  E_Cisco_IOS_XRIpv4IoOper_Ipv4MaOperConfig                                                               `path:"client-type" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ConfigFlags                 *uint16                                                                                                 `path:"config-flags" module:"Cisco-IOS-XR-ipv4-io-oper"`
	DirectBroadcast             *bool                                                                                                   `path:"direct-broadcast" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FlowTagDst                  *bool                                                                                                   `path:"flow-tag-dst" module:"Cisco-IOS-XR-ipv4-io-oper"`
	FlowTagSrc                  *bool                                                                                                   `path:"flow-tag-src" module:"Cisco-IOS-XR-ipv4-io-oper"`
	GwAddressRcvd               *bool                                                                                                   `path:"gw-address-rcvd" module:"Cisco-IOS-XR-ipv4-io-oper"`
	GwPrefixLength              *uint32                                                                                                 `path:"gw-prefix-length" module:"Cisco-IOS-XR-ipv4-io-oper"`
	HelperAddress               *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress      `path:"helper-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IdbPointer                  *uint64                                                                                                 `path:"idb-pointer" module:"Cisco-IOS-XR-ipv4-io-oper"`
	InterfaceName               *string                                                                                                 `path:"interface-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	IsOrEvent                   *bool                                                                                                   `path:"is-or-event" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MaskReply                   *bool                                                                                                   `path:"mask-reply" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MlacpActive                 *bool                                                                                                   `path:"mlacp-active" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Mtu                         *uint32                                                                                                 `path:"mtu" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MultiAcl                    *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl           `path:"multi-acl" module:"Cisco-IOS-XR-ipv4-io-oper"`
	MulticastGroup              []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MulticastGroup   `path:"multicast-group" module:"Cisco-IOS-XR-ipv4-io-oper"`
	NextUnnumberedInterfaceName *string                                                                                                 `path:"next-unnumbered-interface-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OperFlags                   *uint64                                                                                                 `path:"oper-flags" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OrImState                   E_Cisco_IOS_XRIpv4IoOper_ImStateEnum                                                                    `path:"or-im-state" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OrImStateConstraint         E_Cisco_IOS_XRIpv4IoOper_ImStateEnum                                                                    `path:"or-im-state-constraint" module:"Cisco-IOS-XR-ipv4-io-oper"`
	OrImStateRcvd               E_Cisco_IOS_XRIpv4IoOper_ImStateEnum                                                                    `path:"or-im-state-rcvd" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PrefixLength                *uint32                                                                                                 `path:"prefix-length" module:"Cisco-IOS-XR-ipv4-io-oper"`
	PrimaryAddress              *string                                                                                                 `path:"primary-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProtocolState               E_Cisco_IOS_XRIpv4IoOper_Ipv4MaState                                                                    `path:"protocol-state" module:"Cisco-IOS-XR-ipv4-io-oper"`
	ProxyArpDisabled            *bool                                                                                                   `path:"proxy-arp-disabled" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Redirect                    *bool                                                                                                   `path:"redirect" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RgIdExists                  *bool                                                                                                   `path:"rg-id-exists" module:"Cisco-IOS-XR-ipv4-io-oper"`
	RouteTag                    *uint32                                                                                                 `path:"route-tag" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Rpf                         *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf                `path:"rpf" module:"Cisco-IOS-XR-ipv4-io-oper"`
	SecondaryAddress            []*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_SecondaryAddress `path:"secondary-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	SubGwAddress                *string                                                                                                 `path:"sub-gw-address" module:"Cisco-IOS-XR-ipv4-io-oper"`
	UnnumberedInterfaceName     *string                                                                                                 `path:"unnumbered-interface-name" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Unreachable                 *bool                                                                                                   `path:"unreachable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	VrfId                       *uint32                                                                                                 `path:"vrf-id" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) IsYANGGoStruct() {
}

// GetOrCreateAcl retrieves the value of the Acl field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetOrCreateAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl {
	if t.Acl != nil {
		return t.Acl
	}
	t.Acl = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl{}
	return t.Acl
}

// GetOrCreateBgpPa retrieves the value of the BgpPa field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetOrCreateBgpPa() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa {
	if t.BgpPa != nil {
		return t.BgpPa
	}
	t.BgpPa = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa{}
	return t.BgpPa
}

// GetOrCreateHelperAddress retrieves the value of the HelperAddress field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetOrCreateHelperAddress() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress {
	if t.HelperAddress != nil {
		return t.HelperAddress
	}
	t.HelperAddress = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress{}
	return t.HelperAddress
}

// GetOrCreateMultiAcl retrieves the value of the MultiAcl field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetOrCreateMultiAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl {
	if t.MultiAcl != nil {
		return t.MultiAcl
	}
	t.MultiAcl = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl{}
	return t.MultiAcl
}

// GetOrCreateRpf retrieves the value of the Rpf field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetOrCreateRpf() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf {
	if t.Rpf != nil {
		return t.Rpf
	}
	t.Rpf = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf{}
	return t.Rpf
}

// GetAcl returns the value of the Acl struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail. If the receiver or the field Acl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl {
	if t != nil && t.Acl != nil {
		return t.Acl
	}
	return nil
}

// GetBgpPa returns the value of the BgpPa struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail. If the receiver or the field BgpPa is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetBgpPa() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa {
	if t != nil && t.BgpPa != nil {
		return t.BgpPa
	}
	return nil
}

// GetHelperAddress returns the value of the HelperAddress struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail. If the receiver or the field HelperAddress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetHelperAddress() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_HelperAddress {
	if t != nil && t.HelperAddress != nil {
		return t.HelperAddress
	}
	return nil
}

// GetMultiAcl returns the value of the MultiAcl struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail. If the receiver or the field MultiAcl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetMultiAcl() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_MultiAcl {
	if t != nil && t.MultiAcl != nil {
		return t.MultiAcl
	}
	return nil
}

// GetRpf returns the value of the Rpf struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail. If the receiver or the field Rpf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) GetRpf() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Rpf {
	if t != nil && t.Rpf != nil {
		return t.Rpf
	}
	return nil
}

// ΛListKeyMap returns the keys of the Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail struct, which is a YANG list entry.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) ΛListKeyMap() (map[string]interface{}, error) {
	if t.InterfaceName == nil {
		return nil, fmt.Errorf("nil value for key InterfaceName")
	}

	return map[string]interface{}{
		"interface-name": *t.InterfaceName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/acl YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl struct {
	CommonInBound  *string `path:"common-in-bound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	CommonOutBound *string `path:"common-out-bound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Inbound        *string `path:"inbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Outbound       *string `path:"outbound" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_Acl) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/bgp-pa YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa struct {
	Input  *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input  `path:"input" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Output *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output `path:"output" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) IsYANGGoStruct() {
}

// GetOrCreateInput retrieves the value of the Input field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) GetOrCreateInput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input {
	if t.Input != nil {
		return t.Input
	}
	t.Input = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input{}
	return t.Input
}

// GetOrCreateOutput retrieves the value of the Output field
// or returns the existing field if it already exists.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) GetOrCreateOutput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output {
	if t.Output != nil {
		return t.Output
	}
	t.Output = &Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output{}
	return t.Output
}

// GetInput returns the value of the Input struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa. If the receiver or the field Input is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) GetInput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input {
	if t != nil && t.Input != nil {
		return t.Input
	}
	return nil
}

// GetOutput returns the value of the Output struct pointer
// from Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa. If the receiver or the field Output is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) GetOutput() *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output {
	if t != nil && t.Output != nil {
		return t.Output
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/bgp-pa/input YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input struct {
	Destination *bool `path:"destination" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Enable      *bool `path:"enable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Source      *bool `path:"source" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Input) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}

// Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output represents the /Cisco-IOS-XR-ipv4-io-oper/ipv4-network/nodes/node/interface-data/vrfs/vrf/details/detail/bgp-pa/output YANG schema element.
type Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output struct {
	Destination *bool `path:"destination" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Enable      *bool `path:"enable" module:"Cisco-IOS-XR-ipv4-io-oper"`
	Source      *bool `path:"source" module:"Cisco-IOS-XR-ipv4-io-oper"`
}

// IsYANGGoStruct ensures that Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output) IsYANGGoStruct() {
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output) Validate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output.
func (*Cisco_IOS_XRIpv4IoOper_Ipv4Network_Nodes_Node_InterfaceData_Vrfs_Vrf_Details_Detail_BgpPa_Output) ΛBelongingModule() string {
	return "Cisco-IOS-XR-ipv4-io-oper"
}
